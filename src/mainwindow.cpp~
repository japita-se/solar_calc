//     #define DEBUG
// #include "about.h"
 
#define PLUSVERSION
#define WITHTOOLS
#include "checkUpdate.h"
#include "magictable.h"
#include "doubledelegate.h"
#include "inverterCheck.h"
#include "buttonFade.h"

#include "cashflow.h"
#include "ecovalutation.h"
#include "load.h"
#include "hourlyenergyplot.h"
#include "hourlyplot.h"
#include "support.h"
#include "qshadoweditor.h"
#include "surfacewidget.h"
// #include "outreport.h"
#include "proprieta.h"
#include "xmlengine.h"
#include "datipannello.h"
#include "datiinverter.h"
#include "modelsettings.h"
#include "mainwindow.h"
#include "myplot.h"
#include "energyout.h"
#include "mymath.h"
#include "addpv.h"
#include "radiazioneReale.h"
#include "optimumplot.h"
#include "albedo.h"
#include "datiradiazione.h"
#include <QtGui>
#include <cmath>
 #include <QSqlDatabase>
#include <QSqlQueryModel>
#include <QSortFilterProxyModel>
#include <QSqlQuery>
#include <QSqlTableModel>
#include <QSqlError>
#include <QComboBox>
#include <QSqlRecord>
#include <QProgressDialog>
#include <QTreeView>
#include <QModelIndex>
#include <QDesktopWidget>
#include <QRect>
#include <QDoubleSpinBox>
#include <QCheckBox>
#include <QToolBox>
#include <QIcon>
#include <QTableWidget>
#include <QSvgRenderer>
 
 #define pi        3.1415926535897932384626433832795028841971

MainWindow::MainWindow( ) 
{
	 setWindowModified(true);
	urlOwner="";
	ch = new CheckUpdate;
	showItalia = false;
	firstRun = true;
	 currentDate = QDate::currentDate()  ;
 
	
	createInterface();
	createTab();

	modelExtract 	    = new QSqlQueryModel(this); //per caricare punti vicini
	modelRadiazione     = new QSqlQueryModel(this);
	modelRadiazione2    = new QSqlQueryModel(this);

	readSettings();
	#ifdef DEBUG
	qDebug()<<"Conversion="<<convertionDone;
	#endif
	// Connect to database
	
	setupConnection(); /* Crea connessione a dati Enea*/
	
  	setupConnectionToPanel("panels"); /* Crea Connessione a dati sui pannelli*/	

	#ifdef PLUSVERSION
	if(inverterCheck)
	inverterCheck->setDatabase(databasePanelsId);
	#endif

// 	setWindowIcon(QIcon(":/images/app.png"));
	setWindowIcon(QIcon(":/images/logo3.png"));
        setWindowTitle("SolarCalc ");
	
	setAttribute(Qt::WA_QuitOnClose);
	source<<"ENEA"<<"CUSTOM"<<"PVGIS"<<"NASA";
	

	validator = new QRegExpValidator(QRegExp("^[0-8]{1,1}[0-9]{1,1}.[0-9]{1,}|^[9]{1,1}0"),this);
	validator2 = new QRegExpValidator(QRegExp("^[+-0-8]{1,1}[0-9]{1,1}|[0-8]{1,2}|^[9]{1,1}0|^[+-9]{1,1}0"),this);
	validator3 = new QRegExpValidator(QRegExp("[0-5][0-9]|60|[0-9]{1,1}"),this);
	validator4 = new QRegExpValidator(QRegExp("[0-8][0-9]|90|[0-9]{1,1}"),this);
	
	// Valori di riferimento//
	// To be changed for multiple projects //
	 effTemp.fill(0,12);
	 localita.radDirettaAnnuaTotale=0;
	 localita.additionalAzi.resize(0);
	 localita.additionalIncl.resize(0);
	 localita.additionalArea.resize(0);
	 localita.albedoType = con;
	 localita.wind = 0;
	 localita.mounting = rack;
	 localita.mountingHeight = 2.5;
	 localita.utc =0;
	 localita.anno=2009;
	 localita.lat = 0;
	 localita.latGradi =0;
	 localita.latMin =0;
	 localita.latSec =0;
	 localita.lon = 0;
	 localita.lonGradi = 0;
	 localita.lonMin =0;
	 localita.lonSec =0;
	 otherLosses.temperatures.fill(0,12);
	 otherLosses.wind.fill(0,12);
	 otherLosses.thermalModel = 1;//CEA model
	 otherLosses.otherLoss.fill(0,12);
	 localita.alt = 0;
         localita.area = 0;
         localita.incl = 0;
         localita.azi = 0;
         localita.albedo = 0;
	 thisProjectPanel.isValid = false; /*no panel selected at the start*/
	 thisProjectInverter.isValid =false;
	 
	 otherLosses.meanShadowLossFactor=0;
	 otherLosses.totalShadowLossFactor=0;
	 otherLosses.tempPath ="";
	 otherLosses.ombrePath="";
	 localita.tempMin = 0;
	 localita.tempMax = 40;
	 localita.ombreModel   = 0; /*sample and hold*/
	 localita.radCorrModel = 1; /* UNI */
	 localita.tipo         = 0; /* Tilt fixed */
	 localita.concRatio     = 1;
	 localita.source       = radEnea;
	 localita.radUnit      = megajoule;
	 tempDataIsEdited = false;
	 windDataIsEdited = false;
	 doNotLoadTemp	  = false;
	 doNotLoadWind    = false;
	refCurveShown = false;
         radNASAFile           = QCoreApplication::applicationDirPath() + "/nasa2005.txt";
         qDebug()<<"MW start" << radNASAFile;
	 tempNASAFile	       = QCoreApplication::applicationDirPath() + "/22yr_T10M";
	 windNASAFile	       = QCoreApplication::applicationDirPath() + "/10yr_wspd50m";
 	 globalNASAFile	       = QCoreApplication::applicationDirPath() + "/nasaGlobal.txt";
	 estimatedCoordinates = false;
	 firstPassDone 	      = false;
	 resetFlags();
	 projectName = "(Untitled)";
	 projectIsDirty = false;
	/* Altri settaggi*/
	 validForExport = false;
	 recentDirReport   = QDir::homePath();
         recentDir 	   = QDir::homePath();
	 recentDirExport   = QDir::homePath();
	 recentExportDaily = QDir::homePath();
	 recentDirProject  = QDir::homePath();
	 recentSaveProject = QDir::homePath();
         integrationType=custom_;
    	 CS.resize(0);
	RawCash.resize(0);
	NPV.resize(0);
	Interest.resize(0);
	InterestNPV.resize(0);
// 	prepareNasaTemp();

	if (canvas)
				canvas->setType(localita.tipo);
	
	editor = new QShadowEditor(this);		
	connect(editor, SIGNAL(accepted()),SLOT(updateShadowFromEditor()));
	connect(editor, SIGNAL(tableResetted()),SLOT(tableResetted()));
	connect(editor, SIGNAL(shadowChanged()),SLOT(drawShadowFromEditor()));
	sourceRadSettings = new DatiRadiazione;
	updateSourceRadSettings();


 	modelSettings = new ModelSettings(this);

        
	createSettings();
	createActions(); 
	createMenu();
 	

	
	
	QFile f(saveProjectFile);
	xmlBag = new XmlEngine();
	xmlBag->newTree();
	 
	

	setupGuiPanels();
		
// 	#ifdef WITHTOOLS
// 	QProgressBar p(statusBar());
// 	p.show();
// 	p.setMaximum(65000*3);
// 	p.setMinimum(0);
// 	qDebug()<<"Start Inserting NasaRad...";
//  	prepareNasaRad(p,1);
// 	qDebug()<<"Start Inserting NasaTemp...";
// 	prepareNasaTemp(p,2);
// 	qDebug()<<"Start Inserting NasaWind...";
// 	prepareNasaWind(p,3);
// 	#endif

 	statusLabel = new QLabel;
	
	
        statusLabel->setAlignment(Qt::AlignCenter);
        statusLabel->setMinimumSize(statusLabel->sizeHint());
	
        statusLabelWarning = new QLabel(tr("Rad.: Database"));
	statusLabelWarning->setAutoFillBackground(true);
	statusLabelWarning->setFrameShape(QFrame::Box);
	
  	/*statusLabelWarning->setPixmap( warningPixmap)*/;
	 
	statusLabelInverter = new QLabel;
	statusLabelInverter->setFrameShape(QFrame::Box);
	 statusLabelInverter->setIndent(3);
        statusLabelInverter->setAlignment(Qt::AlignCenter);
        statusLabelInverter->setMinimumSize(statusLabelInverter->sizeHint());

	if (energyOut)
        statusLabelEnergy = new QLabel(energyOut->getStatus());
	else
	statusLabelEnergy = new QLabel;
	statusLabelEnergy->setFrameShape(QFrame::Box);
        statusLabelEnergy->setIndent(3);
        statusLabelEnergy->setAlignment(Qt::AlignCenter);
        statusLabelEnergy->setMinimumSize(statusLabelEnergy->sizeHint());
	statusLabel->setIndent(3);
	statusLabelWarning->setIndent(3);
	statusLabelWarning->setAlignment(Qt::AlignCenter);
	statusLabelWarning->setMinimumSize(statusLabelWarning->sizeHint());
	statusLabel->setAlignment(Qt::AlignHCenter);
        statusLabel->setMinimumSize(statusLabel->sizeHint());
	statusBar()->insertPermanentWidget(0,statusLabelInverter,0);
        statusBar()->insertPermanentWidget(1,statusLabelEnergy,0);
        statusBar()->insertPermanentWidget(2,statusLabelWarning,0);
        statusBar()->insertPermanentWidget(3,statusLabel,0);
	statusBar()->showMessage(tr("Pronto"),4000);

	updateTitle(projectName);
	updateStatusBar("Database","darkkhaki");
	updateComponentStatus();

// 	pSplash.finish(this);
// 	 qDebug()<<"MW italiaData"<<italiaData->frameSize().width()<<italiaData->frameSize().height();
//  	bF  = new FaderWidget(italiaData);
	
	resetEnString();
	connect(this,SIGNAL(gNameAvailable(const QString&)),SLOT(setNameDiagramPlot(const QString&)));
}

void MainWindow::setupConnectionToPanel(const QString &id)

{
databasePanelsId = id;
if (!panelsLoaded) {

		// no DB of panels in the settings. Maybe the file exsists....
		 
		
		if ( createConnection(id)) {		
			if (!checkIfDatabase(id,"pannelli")) {
						 
						#ifdef DEBUG
						
						#endif
						// Il database non esiste e non e' stato caricato, ergo creane uno
 					        createTablePanel(id);
						
 			} else {
			// Il db esiste ed e' sano.
			panelsLoaded = true;
			initializeModelPanels(id); 
			}
		} else  
					
			  QMessageBox::critical(this,tr("Database assente"),tr("Problema di connessione con il database ")+id+".",QMessageBox::Ok);
	} else {
		if ( createConnection(id)) 	
			initializeModelPanels(id);
		else
			QMessageBox::critical(this,tr("Connessione Database"),tr("Problema di connessione con il database ")+id+".",QMessageBox::Ok);
	}
}
void MainWindow::setupConnection()
{
if (!convertionDone) {

		// no DB name in the settings. Maybe the file exsists....
		databaseEntry = QCoreApplication::applicationDirPath()+"/datiEnea.db";
		qDebug()<<"ApplicationDir path"<<databaseEntry;
		if ( createConnection()) {		
			if (!checkIfDatabase()) {
						QMessageBox::warning(this,tr("Database Enea assente"),"Database dei dati di radiazione Enea mancante. Caricalo o generalo dopo dal menu Strumenti",QMessageBox::Ok);
						#ifdef DEBUG
						qDebug()<<"Create connetion,convertion"<<convertionDone;
						#endif
						// Il database non esiste e non e' stato caricato, ergo creane uno
 					        createTable();
						
 			}
			// Il db esiste ed e' sano.
			convertionDone = true;
			initializeModel(); 
		} else  
					
			  QMessageBox::critical(this,tr("Database assente"),tr("Problema di connessione con il database Enea. Ricerca comuni non attiva."),QMessageBox::Ok);
	} else {
		if ( createConnection()) 	
			initializeModel();
		else
			QMessageBox::critical(this,tr("Connessione Database"),tr("Problema di connessione con il database Enea. Ricerca comuni non attiva."),QMessageBox::Ok);
	}
}
void MainWindow::createTable()
{
	QSqlQuery q;
	q.prepare("CREATE TABLE radiazione (id INTEGER NOT NULL PRIMARY KEY,	reg INTEGER, prov INTEGER,	comune INTEGER,	targa VARCHAR(3),	nome  VARCHAR(50),	gennaio REAL,	febbraio REAL,	marzo REAL,	aprile REAL,	maggio REAL,	giugno REAL,	luglio REAL,	agosto REAL,	settembre REAL,	ottobre REAL,	novembre REAL,	dicembre REAL,	media REAL, latitudine_g INTEGER,latitudine_m INTEGER,latitudine_s INTEGER,longitudine_g INTEGER,longitudine_m INTEGER,longitudine_s INTEGER)");
	q.exec();
	#ifdef DEBUG
	qDebug()<<"createTable.."<<q.lastError();
	#endif
 
}
void MainWindow::createTablePanel(const QString &type)
{
	QSqlDatabase db=QSqlDatabase::database(type);
	db.setDatabaseName(databasePanels);
	QSqlQuery q(db);
	q.prepare(" CREATE TABLE pannelli ( id INTEGER NOT NULL PRIMARY KEY,costruttore VARCHAR(50),modello VARCHAR(50),pnom REAL,voc REAL,isc REAL,imp REAL,noct REAL,peso REAL,vmp REAL,vmax REAL,beta REAL,alfa REAL,gamma REAL,tolleranza REAL,h REAL,l REAL,s REAL,efficienza REAL, usura REAL)");
	q.exec();
	q.prepare("create table inverter (id INTEGER NOT NULL PRIMARY KEY,costruttore VARCHAR(50),modello VARCHAR(50),pin REAL,pnom REAL,vmax REAL,vmin REAL,vmpmin REAL,vmpmax REAL,imax REAL, efficienza REAL, usura REAL )");
	q.exec();
	
// 	#ifdef DEBUG
	qDebug()<<"createTable in panels."<<q.lastError()<<q.executedQuery()<<q.lastError().text()<<databasePanels;
	qDebug()<<q.lastError().driverText();
// 	#endif
}
void MainWindow::initializeModelPanels(const QString &id)
{
	QSqlDatabase db= QSqlDatabase::database(id);
	modelPanels = new QSqlTableModel(0,db); /* This will be used to list the panels*/
	
}
void MainWindow::initializeModel()
{
	
	
	modelRadiazione->setQuery("SELECT * from radiazione");
	modelRadiazione2->setQuery("SELECT * from radiazione");
  	proxyModel = new QSortFilterProxyModel(this);
  	proxyModel->setSourceModel(modelRadiazione);
	proxyModel->setDynamicSortFilter(true);
//  	proxyModel->setFilterKeyColumn(-1);
	 proxyModel->sort(5, Qt::AscendingOrder); 
// 	comuniView->setModel(modelRadiazione);
	comuniView->setModel(proxyModel);
     	comuniView->setModelColumn(5);
	
	 
	
	 
	
	
// 	qDebug()<<"Problems in initializeModel="<<model->lastError();
}
bool MainWindow::createConnection(const QString &id)
{
	databasePanels = QCoreApplication::applicationDirPath()+"/panels.db";
 	#ifdef DEBUG
	qDebug()<<"database pannelli="<<databasePanels;
 	#endif
	 
	QSqlDatabase db =  QSqlDatabase::addDatabase("QSQLITE",id);
	
	db.setDatabaseName(databasePanels);
	db.open();
  		#ifdef DEBUG
		qDebug()<<"Problems with database panels="<<db.lastError()<<db.isOpen()<<id;
  		#endif
	 
	if (db.isOpen())
		return true;
	else
	
		return false;
}
bool MainWindow::createConnection()
{	
	#ifdef DEBUG
	qDebug()<<"database="<<databaseEntry;
	#endif
	QSqlDatabase db =  QSqlDatabase::addDatabase("QSQLITE");
	
	db.setDatabaseName(databaseEntry);
	db.open();
		#ifdef DEBUG
		qDebug()<<"Problems="<<db.lastError()<<db.isOpen();
		#endif
	if (db.isOpen())
		return true;
	else
	
		return false;


}
 
bool MainWindow::checkIfDatabase(const QString &id,const QString &table)
{
	/*Controlla se il file di database con conn. identificata da id esiste*/
	QFileInfo file(QCoreApplication::applicationDirPath()+"/panels.db");	
	QSqlDatabase temp = QSqlDatabase::database(id);
	if (file.exists()) {
		
		 
		QSqlQuery m(temp);
		m.prepare("SELECT * from "+ table);
		m.exec();
// 	qDebug()<<"checkdatabase"<<m.lastError()<<table<<id;
  	if (!m.isActive()) {	
 
			return false;

		} else {
			return true;
		} 
		
} else {
	return false;
	}
}
bool MainWindow::checkIfDatabase()
{
	// Check if the database is present in the current dir
	QFileInfo file(QCoreApplication::applicationDirPath()+"/datiEnea.db");	
 	QSqlQueryModel m;
	if (file.exists()) {
		QSqlDatabase temp = QSqlDatabase::database();
		temp.setDatabaseName(databaseEntry);
		
		m.setQuery("SELECT * from radiazione");
		
	#ifdef DEBUG
	qDebug()<<m.lastError()<<m.query().executedQuery()<<temp<<m.rowCount();
	#endif 
		if ( (m.rowCount())<10) {
			int r= QMessageBox::question(this,tr("Databe corrotto"),"Il database e' presente ma sembra non valido. Ci sono solo" + QString::number(m.rowCount()) + " chiavi.",QMessageBox::Ok);
			if (r)
				 return true;
			else 
				return false;
		}
		if (!m.query().isActive()) {	
			QMessageBox::critical(this,tr("Database corrotto"),"Il database e' presente ma sembra non valido",QMessageBox::Ok);
			return false;

		} else {
			return true;
		} 
	} else {
			return false;
	}
	
}
void MainWindow::setDamp()
{	
	localita.azi    = aziValue->value();
	localita.incl   = inclValue->value();
	localita.albedo = albedoValue->value();
	localita.anno   = annoValue->value();
	#ifdef DEBUG
	qDebug()<<"Son in setDamp"<<localita.azi<<localita.incl;
	#endif
	initializeModel();
	if (!locValue->text().isEmpty())
	{ 
  		updateLat();
		set();
}
		
// 		
;
		 
		 
}
bool MainWindow::additionalParChanged()
{
	bool o = false;
	
	for(int i=0;i<localita.additionalIncl.size();i++){
		if (localita.additionalIncl.at(i) !=inclValue2->value() ||
		    localita.additionalAzi.at(i)  !=aziValue2->value()||
		    localita.additionalArea.at(i) !=areaValue2->value()){
		o =true;
  		qDebug()<<"MW addPar cahnged=TRUE"<<localita.additionalIncl.at(i);
		}
	}
	return o;
}
bool MainWindow::somethingChanged()
{
	/* This function check if the lat lon incl albedo area have changed */
	if (aziValue->value()!=localita.azi   || 
		inclValue->value()  !=localita.incl     ||
		albedoValue->value()!=localita.albedo  ||
		areaValue->value()!=localita.area      ||
		additionalParChanged() ){
// 		  qDebug()<<"MainWindow SomethingChanged...";
		return true;
               
	}
	else 
	return false;

}
void MainWindow::updateSitePar()
{
			
			if (localita.tipo==2){
			localita.additionalAzi.resize(0);
			localita.additionalIncl.resize(0);
			localita.additionalArea.resize(0);
			localita.additionalAzi<< aziValue2->value();
			localita.additionalIncl<< inclValue2->value();	
			localita.additionalArea<< areaValue2->value();
			}
// 			qDebug()<<"MainWindow updateSitePar..."<<localita.additionalAzi<<localita.additionalIncl;

			localita.azi  = aziValue->value();
			localita.incl = inclValue->value();
                        localita.albedo = albedoValue->value();
			localita.area =areaValue->value() ;
			localita.wind=windValue->value();
			localita.mounting=mountingValue->currentIndex();
			localita.mountingHeight=mountingHeightValue->value();
			localita.concRatio = concRatioValue->value();
			localita.tempMin = tempMinValue->value();
			localita.tempMax = tempMaxValue->value();
// 			otherLosses.otherLoss = otherLoss->value();
}
void MainWindow::setDampOthers( )
{

	
        if (!comuneValue->text().isEmpty() || (!(wrongCoordinates) || (onlyLat) ) || googleNameAvailable || bothCoord) {
		  if (somethingChanged()) {
			qDebug()<<"I am in damp others"<<somethingChanged();		
			updateSitePar();
                	set();	
		 }

            } else {
                    /* update only the shadows */
		    qDebug()<<"Ombre present in Mainwindow"<<ombrePresent;
                    if (ombrePresent)
                                    w->drawMyContents(0);
            // 	qDebug()<<"setDampOther..nonameAv?"<<noNameAvailable;
        updatePower();
        }
// 	updateTempDaily();

	 
        }
void MainWindow::set()
{
	
	 setWindowModified(true);
// 	double Rb[12],Hincl[12];
     	#ifdef DEBUG
	qDebug()<<"set()..wrongCoordinate"<<wrongCoordinates;
	qDebug()<<"set()..onlyLat"<<onlyLat;
	qDebug()<<"set()..noNameAvailable"<<noNameAvailable;
	qDebug()<<"set()..bothCoord"<<bothCoord;
	qDebug()<<"set()..googleName"<<googleNameAvailable;
	qDebug()<<"set()..googleError"<<googleError;
	qDebug()<<"set()..useLoadedLoc"<<useLoadedLoc;
	qDebug()<<"set() localita before computation"<<localita.latGradi<<localita.latMin<<localita.latSec<<localita.lonGradi<<localita.lonMin<<localita.lonSec;
     	#endif

	
	
	if (!(wrongCoordinates) || (onlyLat) || bothCoord || !noNameAvailable || (googleNameAvailable && !googleError ) ||
	      useLoadedLoc||useLoc)
	{
//            qDebug()<<"SET()........................................noNameAvailable"<<noNameAvailable;
		QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
// 			utcValue->setValue(floor((localita.lonGradi+7.5)/15));
			createSolarPlot();
			/* There is a strange bug in th QWT's refresh. The following seems to be necessary */
			if (firstRun){
				createSolarPlot();
				firstRun=false;
			}
			createOptimumPlot();
			setIntegrationInterval();
			w->computeShadow();
			updateLimitDistance(0,localita.incl);
  		
		if (extractRadiazione(localita)) {
 
				noRadiation    = false;
				isDirty = true;
                        	projectIsDirty = true;        
                		createRealePlot();
				createEnergyOutPlot();
				createCheckInverter();
				validForExport = true;
				drawHourlyValues();
				
				
			} else
			{
					noRadiation     = true;
					validForExport = false;
					statusBar()->showMessage(tr("Estrazione radiazione fallita"),2000);
					noRad(onlyRad);
			}	
	#ifdef DEBUG
	qDebug()<<"MW set after"<<validForExport<<noRadiation;
	#endif
	} else	
		{
		validForExport = false;			
		noRad(all);
		
		}
	QApplication::restoreOverrideCursor();		
	//Last check

	


//DEBUG
// QPolygonF f = findNasaData(localita.latGradi,localita.lonGradi);

	}
		
		
 void MainWindow::toFade()
{
	if ((!noNameAvailable)||showItalia)
		pagesWidget->setCurrentIndex(1);
	else
		pagesWidget->setCurrentIndex(0);
}

		

 
void MainWindow::loadEneaData()

{
	confirmErase("radiazione");
	QStringList campi;
	campi<<"reg"<<"prov"<<"comune"<<"targa"<<"nome"<<"gennaio"<<"febbraio"<<"marzo"<<"aprile"<<"maggio"<<"giugno"<<"luglio"<<"agosto"<<"settembre"<<"ottobre"<<"novembre"<<"dicembre"<<"media";
	
	QString fileName= QFileDialog::getOpenFileName(this, tr("Apri"),
                                                     "/home",
                                                     tr("Text File (*.txt *.rtf )"));
	
	if (!fileName.isNull()) {
		
// 	        int count;
		QFile file(fileName);
		QFileInfo fileInfo(fileName);
		QTextStream in(&file);

	// Suppose 10*8byte = 80 byte per line
        int lines = (int)ceil(fileInfo.size()/20);
	QProgressDialog progress(tr("Caricamento dei dati di radiazione..."), tr("Cancella "), 0, lines, this);
  	progress.setWindowModality(Qt::WindowModal);
		if (file.open(QIODevice::ReadOnly)){
			
			int i=0;
			
			while (!in.atEnd()) {
				
				progress.setValue(i);
				 if (progress.wasCanceled()) {
           					  
// 						  model->setQuery("DELETE FROM radiazione");
						  break;
				} else {
					QString lineRaw = in.readLine();	
					QStringList l = lineRaw.split(",");
					QString name = l.at(4);
					name.replace(QString("'"),QString("''")); //escaping single quote
					QString sigla = l.at(3);
					l[4] = "\'" + name + "\'";
					l[3] = "\'" + sigla + "\'";
					QString line;
					line = l.join(",");
					
					
					//QStringLins = line.split(','); //Enea uses comma as separators
	modelRadiazione->setQuery("INSERT INTO radiazione (" + campi.join(",") + ") VALUES ("+line + ")");
	 
	if (modelRadiazione->lastError().isValid()) {
				#ifdef DEBUG
				 qDebug()<<modelRadiazione->lastError()<<("INSERT INTO radiazione (" + campi.join(",") + ") VALUES ("+line + ")");
				#endif
				QMessageBox::critical(this,tr("Errore"),tr("Il database sembra non corretto. Prova a riscaricarlo."),QMessageBox::Ok);
				convertionDone = false;
				return;
					}
					i++;
			
				}	
		 
			convertionDone = true;
			}
		progress.setValue(lines);
		
		}
	}
	int a = QMessageBox::question(this,tr("Dati sui Comuni"),tr("I dati ENEA non contengono le coordinate dei comuni. Per completare l'operazione devi caricare i dati dei Comuni. Carico adesso?"),QMessageBox::Ok,QMessageBox::Cancel);
	
	if (a==QMessageBox::Ok) loadComuniData();
}

void MainWindow::loadComuniData()
{

//   	confirmErase("comuni");
	QString line,lineRaw,reg,prov,com,qS;
	QStringList l;
	QString name,latGradi,latMin,latSec,lonGradi,lonMin,lonSec;
	QStringList campi,campiRad,lineRad;
	QString sigla;
	QSqlQuery query;
	int lines;

	campi<<"reg"<<"prov"<<"comune"<<"latitudine_g"<<"latitudine_m"<<"latitudine_s"<<"longitudine_g"<<"longitudine_m"<<"longitudine_s"<<"altitudine_c"<<"altitudine_m"<<"altitudine_ma"<<"superficie"<<"pop"<<"nome"<<"sigla";  
	
	campiRad<<"latitudine_g"<<"latitudine_m"<<"latitudine_s"<<"longitudine_g"<<"longitudine_m"<<"longitudine_s";

	QString fileName= QFileDialog::getOpenFileName(this, tr("Apri"),
                                                     "/home",
                                                     tr("Text File (*.txt *.rtf )"));
	
	if (!fileName.isNull()) {
		
// 	        int count;
		QFile file(fileName);
		QFile temp(fileName);
		QFileInfo fileInfo(fileName);
		QFileInfo tempInfo(fileName);
		QTextStream inTemp(&temp);
		QTextStream in(&file);
	

	if (temp.open(QIODevice::ReadOnly)) {
		QString t = inTemp.readLine();


                lines = (int)ceil(fileInfo.size()/t.size()*4);
	} else  
		lines=0;
	 
	QProgressDialog progress(tr("Caricamento dei dati sui comuni..."), tr("Cancella "), 0, lines, this);
  	progress.setWindowModality(Qt::WindowModal);
	if (file.open(QIODevice::ReadOnly)){
			
			int i=0;
			
			while (!in.atEnd()) {
				
				progress.setValue(i);
 				 if (progress.wasCanceled()) {
           					  
// 						  model->setQuery("DELETE FROM radiazione");
 						  break;
 				} else {
  					  lineRaw = in.readLine();
// 					qDebug()<<lineRaw;	
  					 l = lineRaw.split(",");
  					  name = l.at(14);
  					name.replace(QString("'"),QString("''")); //escaping single quote
  					sigla = l.at(15);
					l[14] = "\'" + name + "\'";
					l[15] = "\'" + sigla + "\'";

					reg   = l.at(0);
					prov  = l.at(1);
					com   = l.at(2);
					latGradi = l.at(3);
					latMin   = l.at(4);
					latSec   = l.at(5);
					lonGradi = l.at(6);
					lonMin   = l.at(7);
					lonSec	 = l.at(8);

  					line = l.join(","); 
// 					
					lineRad.clear();
					lineRad << l.at(3)<<l.at(4)<<l.at(5)<<l.at(6)<<l.at(7)<<l.at(8);		
// 					
 					//QStringLins = line.split(','); //Enea uses comma as separators
//  					model->setQuery("INSERT INTO comuni (" + campi.join(",") + ") VALUES ("+line + ")");
	qS = "UPDATE radiazione SET latitudine_g="+latGradi+",latitudine_m="+latMin+",latitudine_s="+latSec+",longitudine_g="+lonGradi+",longitudine_m="+lonMin+",longitudine_s="+lonSec+"  WHERE reg="+reg+" AND prov="+prov+" AND comune="+com;


  			modelRadiazione->setQuery(qS);
					 #ifdef DEBUG
 					 qDebug()<<modelRadiazione->lastError()<<qS;
 					 #endif
					i++;
// 				 
				}	
		 
			convertionDone = true;
			initializeModel();
			}
// 		progress.setValue(lines);
		
		}
	
	}

 }
 
void MainWindow::exportPDF()
{
// 	switch (tabWidget->currentIndex()) {
// 		case 0:
// 		w->exportPDF();
// 		break;
// 		case 1:
// 		o->exportPDF();
// 		break;
// 		case 2:
// 		reale->exportPDF();
// 		break;
// 		case 3:
// 		energyOut->exportPDF();
// 	}
	
}
void MainWindow::createActions()
{
	 for (int i = 0; i < MaxRecentFiles; ++i) {
       		 recentFileActions[i] = new QAction(this);
        	 recentFileActions[i]->setVisible(false);
      		  connect(recentFileActions[i], SIGNAL(triggered()),this, SLOT(openRecentFile()));
    }


	a_export = new QAction(tr("Esporta dati (*.txt)"),this);
	a_export->setShortcut(tr("Ctrl+E"));
	a_export->setIcon(QIcon(":/images/export.png"));
	a_export->setStatusTip(tr("Esporta risultati di radiazione in formato testo"));
	connect(a_export,SIGNAL(triggered()),this,SLOT(exportData()));

	a_export_daily = new QAction(tr("Esporta dati giornalieri interpolati"),this);
	a_export_daily->setShortcut(Qt::CTRL +Qt::SHIFT + Qt::Key_D);
	connect(a_export_daily,SIGNAL(triggered()),SLOT(exportDaily()));

	a_exportPDF = new QAction(tr("Esporta PDF"),this);
	a_exportPDF->setIcon(QIcon(":/images/adobe.ico"));
	a_exportPDF->setStatusTip(tr("Esporta in PDF il minireport"));
	connect(a_exportPDF,SIGNAL(triggered()),SLOT(exportPDF()));

	a_impostazioni = new QAction(tr("Impostazioni"),this);	
	a_impostazioni->setShortcut(tr("Ctrl+I"));
	a_impostazioni->setIcon(QIcon(":/images/settings.png"));
	a_impostazioni->setStatusTip(tr("Impostazioni del modello e delle ombre"));
	connect(a_impostazioni,SIGNAL(triggered()),SLOT(updateModelSettings()));

	a_quit   = new QAction(tr("Esci"),this);
	a_quit->setShortcut(tr("Ctrl+Q"));
	a_quit->setStatusTip(tr("Esci"));
	connect(a_quit,SIGNAL(triggered()),SLOT(close()));

	a_refresh = new QAction(tr("Aggiorna"),this);
	a_refresh->setShortcut(tr("Ctrl+R"));
	a_refresh->setIcon(QIcon(":/images/arrow.png"));
	connect(a_refresh,SIGNAL(triggered()),SLOT(set()));

	
	a_load_data = new QAction(tr("Carica dati"),this);
	a_load_comuni = new QAction(tr("Carica comuni"),this);
	a_load_comuni->setStatusTip(tr("Carica il database Enea-Istat dei Comuni italiani"));
	connect(a_load_data,SIGNAL(triggered()),this,SLOT(loadEneaData()));	
	connect(a_load_comuni,SIGNAL(triggered()),this,SLOT(loadComuniData()));	 
	
// 	a_view_solar = new QAction(tr("&Diagramma solare"),this);	
	
	a_view_opti = new QAction(tr("&Variazione Tilt"),this);
	a_view_opti->setShortcut(tr("Ctrl+T"));
	a_view_opti->setIcon(QIcon(":/images/opti2.png"));
	a_view_opti->setStatusTip(tr("Mostra il diagramm del tilt ottimo rispetto al piano orizzontale"));
// 	a_view_opti->setCheckable(true);
	connect(a_view_opti,SIGNAL(triggered(bool)),this,SLOT(viewOpti()));	

	a_view_reale = new QAction(tr("Radiazione reale"),this);
	a_view_reale->setShortcut(tr("Ctrl+E"));
	a_view_reale->setIcon(QIcon(":/images/falling-leaves.ico"));	
	a_view_reale->setStatusTip(tr("Mostra il diagramma della radiazione reale compresa di ombreggiamenti"));
// 	a_view_reale->setCheckable(true);
		connect(a_view_reale, SIGNAL(triggered()),this,SLOT(viewReale()));

	a_get_albedo = new QAction(tr("&Albedo"),this);
	a_get_albedo->setIcon(QIcon(":/images/albedo.ico"));
	a_get_albedo->setShortcut(tr("Ctrl+B"));
	a_get_albedo->setStatusTip(tr("Imposta il valore di albedo"));
	connect(a_get_albedo,SIGNAL(triggered()),SLOT(viewAlbedo()));

	
 
	 
	a_load_shadow = new QAction(tr("Carica ombre"),this);
	a_load_shadow->setShortcut(Qt::CTRL + Qt::Key_O);
	a_load_shadow->setIcon(QIcon(":/images/shade.ico"));
	a_load_shadow->setStatusTip(tr("Carica i dati d'ombra"));

	a_delete_shadow = new QAction(tr("Rimuovi ombre"),this);
	a_delete_shadow->setShortcut(tr("Ctrl+X"));
	a_delete_shadow->setIcon(QIcon(":/images/delete-shade.ico"));
	a_delete_shadow->setStatusTip(tr("Elimina le ombre"));
	connect(a_load_shadow,SIGNAL(triggered()),SLOT(loadShadow()));
	connect(a_delete_shadow,SIGNAL(triggered()),w,SLOT(deleteShadow()));
	
  	a_check_custom = new QAction(tr("Sorgente"),this);
	a_check_custom->setStatusTip(tr("Seleziona la sorgente dati di radiazione"));
  	connect(a_check_custom,SIGNAL(triggered()),SLOT(setRadData()));

	a_add_component = new QAction(tr("Aggiungi componenti"),this);
	a_add_component->setStatusTip(tr("Aggiungi moduli FV o inverter al database componenti"));
	a_add_component->setIcon(QIcon(":/images/addcomponent.png"));
	connect(a_add_component,SIGNAL(triggered()),SLOT(addPV()));

	a_select_component = new QAction(tr("Selezione pannello"),this);
	a_select_component->setStatusTip(tr("Seleziona un pannello fv dal database"));
	a_select_component->setShortcut(tr("Ctrl+W"));
 	a_select_component->setIcon(QIcon(":/images/selectcomponent.png"));
	connect(a_select_component,SIGNAL(triggered()),SLOT(selectPV()));

	a_select_inv = new QAction(tr("Selezione Inverter"),this);
	a_select_inv->setStatusTip(tr("Seleziona un inverter dal database"));
	a_select_inv->setShortcut(tr("Ctrl+Shift+I"));
 	a_select_inv->setIcon(QIcon(":/images/selectinv.png"));
	connect(a_select_inv,SIGNAL(triggered()),SLOT(selectInv()));

	a_save_project = new QAction(tr("Salva progetto"),this);
	a_save_project->setStatusTip(tr("Salva il progetto corrente"));
	a_save_project->setShortcut(tr("Ctrl+S"));
	a_save_project->setIcon(QIcon(":/images/save.png"));
	connect(a_save_project,SIGNAL(triggered()),SLOT(save()));

	a_saveas_project = new QAction(tr("Salva progetto con nome"),this);
	a_saveas_project->setStatusTip(tr("Salva il progetto corrente con un nuovo nome"));
	a_saveas_project->setShortcut(tr("Ctrl+S+A"));
	a_saveas_project->setIcon(QIcon(":/images/filesaveas.png"));
	connect(a_saveas_project,SIGNAL(triggered()),SLOT(saveAs()));

	a_load_project = new QAction(tr("Apri progetto"),this);
	a_load_project->setStatusTip(tr("Apre un progetto "));
	a_load_project->setShortcut(tr("Ctrl+O"));
	a_load_project->setIcon(QIcon(":/images/open.png"));
	connect(a_load_project,SIGNAL(triggered()),SLOT(load()));

	a_new_project = new QAction(tr("Nuovo progetto"),this);
	a_new_project->setStatusTip(tr("Crea un nuovo progetto "));
	a_new_project->setShortcut(tr("Ctrl+N"));
	a_new_project->setIcon(QIcon(":/images/new.png"));
	connect(a_new_project,SIGNAL(triggered()),SLOT(newProject()));
	
//	a_create_daily = new QAction(tr("Genera dati giornalieri"),this);
//	a_create_daily->setStatusTip(tr("Genera dati di radiazione giornalieri interpolati sulla base di dati medi mensili di radiazione "));
//	a_create_daily->setShortcut(tr("Ctrl+F"));
//	a_create_daily->setIcon(QIcon(":/images/fit.png"));
//	connect(a_create_daily,SIGNAL(triggered()),SLOT(createDailyRealePlot()));

	a_property = new QAction(tr("Lingua"),this);
	a_property->setStatusTip(tr("Cambia Lingua"));
	a_property->setShortcut(tr("Ctrl+Shift+O"));
	connect(a_property,SIGNAL(triggered()),SLOT(updateOptions()));

	
	a_suggest = new QAction(tr("Wizard"),this);
	a_suggest->setStatusTip(tr("Calcola area captante in base ai consumi"));
	a_suggest->setShortcut(tr("Ctrl+Shift+S"));
	a_suggest->setIcon(QIcon(":/images/wizard.png"));
	connect(a_suggest,SIGNAL(triggered()),SLOT(wizard()));

	a_print_report = new QAction(tr("Stampa report PDF"),this);
	a_print_report->setIcon(QIcon(":/images/print.png"));
	a_print_report->setShortcut(tr("Ctrl+Shift+P"));
	a_print_report->setStatusTip(tr("Stampa rapporto sintetico in PDF"));
	connect(a_print_report,SIGNAL(triggered()),SLOT(print()));

	a_print_preview = new QAction(tr("Anteprima di stampa minireport"),this);
// 	a_print_report->setIcon(QIcon(":/images/print.png"));
// 	a_print_report->setShortcut(tr("Ctrl+Shift+P"));
	a_print_preview->setStatusTip(tr("Anteprima di stampa del rapporto sintetico"));
	connect(a_print_preview,SIGNAL(triggered()),SLOT(printPreview()));

	
	a_about = new QAction(tr("Info"),this);
 	connect(a_about,SIGNAL(triggered()),SLOT(about()));

	a_shadow_editor = new QAction(tr("Editor di ombre"),this);
	a_shadow_editor->setIcon(QIcon(":/images/editorshadow.png"));
	a_shadow_editor->setStatusTip(tr("Apre l'editor di ombre vicine"));
	connect(a_shadow_editor,SIGNAL(triggered()),SLOT(newShadowEditor()));

#ifdef PLUSVERSION
	a_eleload_editor = new QAction(tr("Consumi e carichi elettrici"),this);
	a_eleload_editor->setIcon(QIcon(":/images/editorconsumi.png"));
	a_eleload_editor->setStatusTip(tr("Apre l'editor dei consumi elettrici"));
	connect(a_eleload_editor,SIGNAL(triggered()),SLOT(openLoad()));

	a_simulate = new QAction(tr("Simulazione energetica"),this);
	a_simulate->setIcon(QIcon(":/images/play.png"));
	a_simulate->setStatusTip(tr("Lancia la simulazione oraria per la valutazione dei contributi energetici associati al sistema"));
	connect(a_simulate,SIGNAL(triggered()),SLOT(simulateNew()));

	a_simulate_redo = new QAction(tr("Lancia o ripete la simulazione economica con dati energetici precedenti"),this);
	a_simulate_redo->setIcon(QIcon(":/images/play2.png"));
	a_simulate_redo->setStatusTip(tr("Lancia la simulazione economica precedente per la valutazione dei flussi monetari associati al sistema. Si assume che solo i parametri economici sono cambiati"));
	connect(a_simulate_redo,SIGNAL(triggered()),SLOT(simulateNewEco()));

	a_ecoval = new QAction(tr("Configura parametri economici"),this);
	a_ecoval->setIcon(QIcon(":/images/ecopara.png"));
	a_ecoval->setStatusTip(tr("Configura i parametri economici associati all'allacciamento del sistema alla rete elettrica"));
	connect(a_ecoval,SIGNAL(triggered()),ecoVal,SLOT(show()));
#endif
	a_check_update = new QAction(tr("Controlla aggiornamenti"),this);
	a_check_update->setStatusTip(tr("Controlla se vi sono aggiornamenti per la versione corrente di SolarCacl"));
	connect(a_check_update,SIGNAL(triggered()),SLOT(checkUpdates()));
}
void MainWindow::createMenu()
{
	fileMenu = menuBar()->addMenu(tr("&File"));
	fileMenu->addAction(a_new_project);
	fileMenu->addAction(a_load_project);
	fileMenu->addAction(a_save_project);
	fileMenu->addAction(a_saveas_project);
	fileMenu->addAction(a_impostazioni);
        fileMenu->addAction(a_property);
	fileMenu->addAction(a_export);
	fileMenu->addAction(a_print_report);
	fileMenu->addAction(a_print_preview);
// 	exportMenu = fileMenu->addMenu(tr("Esporta"));
	
// 	exportMenu->addAction(a_export_daily);
	 separatorAction = fileMenu->addSeparator();
	for (int i = 0; i < MaxRecentFiles; ++i)
        fileMenu->addAction(recentFileActions[i]);

	fileMenu->addSeparator();
	fileMenu->addAction(a_quit);

	viewMenu = menuBar()->addMenu(tr("&Visualizza"));
// 	viewMenu->addAction(dockParametri->toggleViewAction());
  //	viewMenu->addAction(dockMyPlot->toggleViewAction());
// 	viewMenu->addAction(dockOpti->toggleViewAction());
// 	viewMenu->addAction(a_view_solar);
  	viewMenu->addAction(a_view_opti);
  	viewMenu->addAction(a_view_reale);
// 	viewMenu->addAction(a_impostazioni);
	viewMenu->addAction(a_refresh);
	 

// 	toolMenu = strummenti->addMenu(tr("Carica &dati"));
	dataMenu = menuBar()->addMenu(tr("Dati"));
	dataMenu->addAction(a_check_custom);
	  

	strumentiMenu = menuBar()->addMenu(tr("&Strumenti"));
	strumentiMenu->addAction(a_suggest);
	strumentiMenu->addAction(a_get_albedo);
	
	eneaMenu = strumentiMenu->addMenu(tr("Carica dati Enea"));
	eneaMenu->addAction(a_load_data);
	eneaMenu->addAction(a_load_comuni);
	
// 	radMenu = strumentiMenu->addMenu(tr("Carica radiazione custom"));
// 	radMenu->addAction(a_load_rad);
	
	ombreMenu =strumentiMenu->addMenu(tr("&Carica Ombre"));
	ombreMenu->addAction(a_load_shadow);
	ombreMenu->addAction(a_delete_shadow);
	ombreMenu->addAction(a_shadow_editor);

	strumentiMenu->addSeparator();
	strumentiMenu->addAction(a_add_component);
	strumentiMenu->addAction(a_select_component);
	strumentiMenu->addAction(a_select_inv);
	
	strumentiMenu->addSeparator();
#ifdef PLUSVERSION
	strumentiMenu->addAction(a_ecoval);
	strumentiMenu->addAction(a_eleload_editor);
	
	strumentiMenu->addAction(a_simulate);
	strumentiMenu->addAction(a_simulate_redo);
#endif
	aboutMenu = menuBar()->addMenu(tr("Aiuto"));
	aboutMenu->addAction(a_about);

	aboutMenu->addAction(a_check_update);
	
	/*create toolbar*/
	toolBar = new QToolBar(this);
	addToolBar(Qt::TopToolBarArea,toolBar);
	toolBar->addAction(a_new_project);
	toolBar->addAction(a_load_project);
	toolBar->addAction(a_save_project);
	toolBar->addAction(a_saveas_project);
	toolBar->addAction(a_impostazioni);
	toolBar->addAction(a_export);
// 	toolBar->addAction(a_exportPDF);
	toolBar->addAction(a_print_report);

        
	toolBarView = new QToolBar(this);
	addToolBar(Qt::TopToolBarArea,toolBarView);
	toolBarView->addAction(a_view_opti);
	toolBarView->addAction(a_view_reale);
	toolBarView->addAction(a_refresh);

	toolBar2 = new QToolBar(this);
        addToolBar(Qt::TopToolBarArea,toolBar2);
        
        
        toolBar2->addAction(a_suggest);
	toolBar2->addAction(a_get_albedo);
      

        toolBar3 = new QToolBar(this);
        addToolBar(Qt::TopToolBarArea,toolBar3);
        toolBar3->addAction(a_load_shadow);
        toolBar3->addAction(a_delete_shadow);
        toolBar3->addAction(a_shadow_editor);


        toolBar4 = new QToolBar(this);
        addToolBar(Qt::TopToolBarArea,toolBar4);
        toolBar4->addAction(a_add_component);
        toolBar4->addAction(a_select_component);
        toolBar4->addAction(a_select_inv);



	/*To be divided*/
        toolBar5 = new QToolBar(this);
        addToolBar(Qt::TopToolBarArea,toolBar5);
//         addToolBar(Qt::TopToolBarArea,toolBar3);
        #ifdef PLUSVERSION
	toolBar5->addAction(a_ecoval);
        toolBar5->addAction(a_eleload_editor);
        toolBar5->addAction(a_simulate);
        toolBar5->addAction(a_simulate_redo);
	#endif

	toolBar6 = new QToolBar(this);
	addToolBar(Qt::TopToolBarArea,toolBar6);
	toolBar6->addWidget(new QLabel(tr("Anno")));
	toolBar6->addWidget(annoValue);
	toolBar6->addWidget(new QLabel(tr("Mese")));
	toolBar6->addWidget(selectMonth);
	toolBar6->addWidget(new QLabel(tr("Giorno")));
	toolBar6->addWidget(selectDay);

        toolBar7 = new QToolBar(this);
        addToolBar(Qt::TopToolBarArea,toolBar7);

        toolBar7->addWidget(new QLabel(tr("Falda corrente"))) ;
        toolBar7->addWidget(comboCurrentField );



}
void MainWindow::updateOptions()
{
	Proprieta prop;
	switch (language){
		case 0:
		break;/* default is italian */
		case 1:
		prop.setLanguage(1);	
		break;/*english*/
		default:
		prop.setLanguage(0);
	}
	
	
	if (prop.exec()){
		language = prop.getLang();
		qDebug()<<"LAnguage="<<language;
		}
}
void MainWindow::openLoad()
{
	if (loadInterface)
		loadInterface->show();
}
void MainWindow::getLoad()
{
	int m = selectMonth->currentIndex();
	int day = selectDay->currentIndex();
	QPolygonF l;
	 
	 
		if (hourlyEOPlot){
		l = loadInterface->getHourlyLoads(localita.anno,day+1,m+1);
		hourlyEOPlot->setLoad(l);
		hourlyEOPlot->enableDrawingLoads(checkDrawLoads->isChecked());
		}
	 
}
void MainWindow::updateSourceRadSettings()
{
	if (localita.source == radEnea)
	sourceRadSettings->radioEnea->setChecked(true);
	if (localita.source == radCustom)
	sourceRadSettings->radioCustom->setChecked(true);
	if (localita.source == radNasa)
	sourceRadSettings->radioNasa->setChecked(true);
	//if (localita.source == radPvgis)
	//sourceRadSettings->radioPvgis->setChecked(true);
	if (localita.radUnit == radPvgis)
	sourceRadSettings->radioPvgis->setChecked(true);
	if (localita.radUnit == megajoule)
	sourceRadSettings->radioMJ->setChecked(true);
	else
	sourceRadSettings->radioKWh->setChecked(true);
}
void MainWindow::setRadData( )
{	
	 
// 	 if (radSource == radEnea)
// 	 r->radioEnea->setChecked(true);
// 	 if (radSource == radCustom)
// 	 r->radioCustom->setChecked(true);
	if (sourceRadSettings->exec()) {
		if (sourceRadSettings->radioEnea->isChecked()){
// 			qDebug()<<"radioEnea is Checked"<<sourceRadSettings->radioEnea->isChecked();
			localita.source = radEnea;
		}
		if (sourceRadSettings->radioCustom->isChecked()){
			
			localita.source = radCustom;
// 			qDebug()<<"radioCustom is Checked"<<sourceRadSettings->radioCustom->isChecked()<<"localita.source"<<localita.source;
			QPolygonF temp(sourceRadSettings->getCustomHg());
			if (temp.size()>0)
				customHg = temp;
			else
			    resetCustomHg();
		}

		if (sourceRadSettings->radioNasa->isChecked()) 
			localita.source = radNasa;

		
		
		if (sourceRadSettings->radioKWh->isChecked() ) 
			localita.radUnit = kwh;
		else
			localita.radUnit = megajoule;

	if (sourceRadSettings->isDirty()) {
		statusLabel->setText(tr("Sorgente: ") + source.at(localita.source));
		set();
		sourceRadSettings->setDirty( false);	
		}
	}
	
}

void MainWindow::addPV()
{
	AddPv form(this);
	form.setConnId(databasePanelsId);
	if (form.exec()) {
		if (datiPanels)
			datiPanels->refreshView();
		if (datiInverter)
			datiInverter->refreshView();
	 
	}
}
void MainWindow::selectInv()
{
if (datiInverter)
	datiInverter->refreshView();
		if (datiInverter->exec()) {
		thisProjectInverter = datiInverter->getSelectedInverter();
 		qDebug()<<"selecInv:"<<thisProjectInverter.isValid<<thisProjectInverter.eff<<thisProjectInverter.pnom;
		if (thisProjectInverter.isValid){
			#ifdef PLUSVERSION
			 if (inverterCheck)
				inverterCheck->setInverter(thisProjectInverter);
			#endif
			 updatePower();
			 }
		}
	updateComponentStatus();

}
void MainWindow::selectPV()
{
	if (datiPanels)
		datiPanels->refreshView();
		if (datiPanels->exec()) {
		
		thisProjectPanel = datiPanels->getSelectedPanel();
  #ifdef DEBUG
	qDebug()<<"selecPV:"<<thisProjectPanel.isValid<<thisProjectPanel.eff<<thisProjectPanel.pnom<<thisProjectPanel.indexDB;
  #endif
		if (thisProjectPanel.isValid){
			if (energyOut)
				energyOut->setPanel(thisProjectPanel);
			
			if (areaValue)
				changeNumPanels(areaValue->value());	
			updatePower();
		}
		
		initializeModel();	 
		}
	updateLimitDistance();
	updateComponentStatus();
	
}
//double MainWindow::wattUnit()
//{
//	double factor;
//
//	if (wattCombo->currentIndex()>0)
//            factor = 3.6;
//        else
//            factor =1;
//
//	return factor;
//}
void MainWindow::exportDaily()
{
	QString m;
	if (validForExport){
		QString fileName = QFileDialog::getSaveFileName(this, tr("Esporta dati"),
                                 recentExportDaily,
                                tr("Text (*.txt *.dat *.rtf)"));
	QFileInfo fileInfo(fileName);
	QFile file(fileName);
	qDebug()<<fileInfo.path();
		if (!fileName.isEmpty() && file.open(QFile::WriteOnly)) {
		recentExportDaily = fileInfo.absoluteDir().absolutePath();
		 
		QTextStream out(&file);
		out.setFieldWidth(8);
		out.setFieldAlignment(QTextStream::AlignLeft);
		 
			if (reale->getDailyHinclOmbre().size()>0)
				out<<'\n';
				for(int i=0;i<MyMath::yearEnd(localita.anno);i++) {
				m = getMonthString(i);
				out<<m<<" "<<reale->getDailyHinclOmbre().at(i).x()<<reale->getDailyHinclOmbre().at(i).y()<<'\n';
				}
		
		}
	}
}

void MainWindow::exportData()
{
// 	double* ombre;
	QVector<double> ombre;
	double e,eTemp,eTemp2;
	ombre = w->getShadowFactor();
	



	if (validForExport) {
	QString fileName = QFileDialog::getSaveFileName(this, tr("Esporta dati"),
                                recentDirExport,
                                tr("Text (*.txt *.dat *.rtf)"));
	// Check the forma....TO DO
	QFile file(fileName);
	QFileInfo fileInfo(file);
	if (!fileName.isEmpty() && file.open(QFile::WriteOnly)) {
		recentDirExport = fileInfo.absoluteDir().absolutePath();
		QTextStream out(&file);
		out.setFieldWidth(15);
		out.setFieldAlignment(QTextStream::AlignLeft);
		/*Start preamble*/
		printPreamble(out);
		
		/*QString a(tr("Mese") + "\t" +tr("Rad.Reale") +"\t"+ tr("Rb")+"\t"+tr("Ombre")+ "\t"+tr("Energia-mensile")+"\n");
	out<<tr("Mese")<<'\t'<<tr("Rad.Reale")<<'\t'<<tr("Rb")<<'\t'<<tr("Ombre")<<'\n'*/
;
		out <<'\n'<<tr("Mese")
			<<tr("Rad.Reale");
			
		if (localita.tipo==2){
			out<<tr("Rb falda1 ")
			<<tr("Rb falda2 ")
			<< tr("Fattore-Ombra 1 ")
			<< tr("Fattore-Ombra 2 ")
			<<tr("Fattore-temp. 1 ")
			<<tr("Fattore-temp. 2 ");
		}
		else
		{
			out<<tr("Rb falda ")
			<< tr("Fattore-Ombra");
		}
			
			out<<tr("Energia-mensile")<<'\n';		

		for(int i=0;i<12;i++) {
// 		QString str;
// 		str = QString("%1 \t %2 \t %3 \t %4 \n").arg(i+1).arg(HinclOmbre[i]).arg(Rb[i]).arg(ombre[i]);
// 		out<<str;
		#ifdef DEBUG
		qDebug()<<"MainWindow: energyPlotPresent"<<energyPlotPresent<<energyOut->getStatus(1);
		#endif
 		if (energyPlotPresent)  {
			e = Energy[i];
			eTemp = effTemp.at(i);
			if (localita.tipo ==2)
				eTemp2 = effTemp.at(i);
		}
			
		else
		{
			e = 0;
			eTemp =0;
		}
		
			out <<i+1
			   <<HinclOmbre[i];
		if (localita.tipo==1){
			   out<<RbBiAx[i];
			   out<<ombre[i];
			   out<<eTemp;
		}
		if  (localita.tipo==0){
			   out<<Rb[i];
			   out<<ombre[i];
		           out<<eTemp;
		}
		if (localita.tipo==2){
			   out<<Rb[i]<<addOmegaRb.at(i);
			   out<<ombre[i]<<addOmbre.at(i);/*It is only one more facade!*/
			   out<<eTemp<<eTemp2;
		}
			   
			   out<<e<<'\n';
// 		qDebug()<<"MW RB"<<Rb[i];
		}
	}
}	
}
void MainWindow::viewOpti( )
{/*
	if (isDirty) {*/
// 			o->compute();
// 			o->drawContents(1);
// 			isDirty = false;
// // 	 	 }

// 	tabWidget->setCurrentIndex(1);
 	if (!optiWidget->isVisible()) {
// 		 
 	optiWidget->show();
 	}
}
void MainWindow::viewMonthlyLoss()
{
	
	if (monthlyLoss) {
		if (monthlyLoss->exec())
		{
			otherLosses.otherLoss = monthlyLoss->getLosses();
			if (monthlyLoss->isDirty())
			{
				double a;
				updatePower();
				monthlyLoss->makeDirty(false);
				a = MyMath::mean(otherLosses.otherLoss);
				otherLoss->setText(QString::number(a));
				qDebug()<<"MW losses"<<a;
			}
		}
			
	}
}
void MainWindow::viewAlbedo()
{
	Albedo albedoTable;
	
	if (localita.albedoType==con){
		albedoTable.setAlbedo(localita.albedo);	
		}
	
		albedoTable.setAlbedoType(localita.albedoType);
	if (albedoTable.exec()) {
		
		localita.albedo = albedoTable.getAlbedo();
		localita.albedoType = albedoTable.getAlbedoModel();
		albedoValue->setValue(localita.albedo);
		
		qDebug()<<"MW get ALbedo"<<localita.albedoType<<localita.albedo;
		updatePower();
}	}

void MainWindow::viewReale( )
{
	
// 	if (isDirty) {
// 			reale->compute();
//   			reale->drawContents(1);
//   			Hincl = reale->getHincl(Hincl);
// 			isDirty=false;
// // 	qDebug()<<"is dirty"<<isDirty;
//   		}
	tabWidget->setCurrentIndex(1);
// 	if (!realeWidget->isVisible()) {
//  		
// 	realeWidget->show();
// 	}
}

void MainWindow::readSettings()

{QSettings settings;
	 if (settings.contains("lang"))
	language = settings.value("lang").toInt();
	qDebug()<<"Language readSettings="<<language;	

	qDebug()<<settings.value("pos").toString();
	QRect r;
	QDesktopWidget screen;
	r = screen.screenGeometry();	

	
        settings.beginGroup("mainWindow");

        resize(settings.value("size",QSize((int)ceil(r.width()/2),(int)ceil(r.height()/2))).toSize());
        move(settings.value("pos",QPoint(200,200)).toPoint());
	restoreGeometry(settings.value("geometry").toByteArray());
// 	toolBox->setMinimumWidth(settings.value("toolbox").toInt());
	recentFiles = settings.value("recentFiles").toStringList();
	settings.endGroup();
	

	settings.beginGroup("database");

	if (settings.contains("databaseName")) {
		if (!settings.value("databaseName").toString().isEmpty()){
			convertionDone = true;

			databaseEntry = settings.value("databaseName").toString();
			
		} else  
			convertionDone = false;
			

			
	} else 	 
			convertionDone = false;
			
	if (settings.contains("databasePanels")) {
		if (!settings.value("databasePanels").toString().isEmpty()) {
			panelsLoaded = true;
			databasePanels = settings.value("databasePanels").toString();
		} else
			panelsLoaded = false;
	} else
			panelsLoaded = false;
	 
	
	settings.endGroup();

	
		
	 
}

void MainWindow::writeSettings()
{
	
        QSettings settings;
	settings.setValue("lang",language);
	settings.beginGroup("mainWindow");
        settings.setValue("pos",pos());
        settings.setValue("size",size());
        settings.setValue("geometry",  saveGeometry());
	settings.setValue("recentFiles",recentFiles);
// 	settings.setValue("toolBox",toolBox->width());
	
        settings.endGroup();
  	
    	 
	if (convertionDone) {
		settings.beginGroup("database");
		settings.setValue("databaseName",databaseEntry);
		settings.endGroup();
	}

	 
	
 

	
}
void MainWindow::setLang(int i)
{
	if (i>=0)
		language = i;
	else
		language = 0;	

}

void MainWindow::updateLatFromGoogle(double a,double b,QString& address)
{
	
	/* We assume that google returns valid coordinates */
	localita.latGradi = MyMath::degree(a);
	localita.latMin   = MyMath::minute(a);
	localita.latSec   = MyMath::seconds(a);
	localita.lonGradi = MyMath::degree(b);
	localita.lonMin   = MyMath::minute(b);
	localita.lonSec   = MyMath::seconds(b);
	localita.name     = address;
	localita.lat      = a;
	localita.lon      = b;
 	qDebug()<<"I am going to call formatCoodinates"<<address;
	formatCoordinates();
	updateComuneLabel(1);
	wrongCoordinates= false;
	googleNameAvailable = true;
	noNameAvailable = true;
	bothCoord = true;
	comuneValue->setText(""); /* in general we suppose that there is no name in italian db */
// 	getCityFromCo(3); /* Here we try to find a city in the italian dataBase  */
	set();
}
void MainWindow::updateLat()
{
// 	resetFlags();
	wrongCoordinates = true;
	noNameAvailable  = true;
	googleNameAvailable = false;
	googleError = true;
	onlyLat = false;
	bothCoord = false;
	QStringList s,co,coDecimal,coDecimal1,coDecimal2;
	QString sNum,sNum2,sNum1;
	bool  ok, ok1, ok2;
	int numCo;
	 


	if (!locValue->text().isEmpty() & (!locValue->text().isNull())) {
		// CONTROLLO SE HO INSERITO DEI NUMERI
		 	
		s = locValue->text().split(",");
				
				#ifdef DEBUG
				qDebug()<<"size della stringa ="<<s.size();
				#endif
				if (s.size()==1) {
					
					coDecimal = s.at(0).split('/');
					sNum = s.at(0);
					sNum.remove(QChar('/'),Qt::CaseInsensitive);
					double  r = sNum.toDouble(&ok);
					#ifdef DEBUG
					qDebug()<<"Nome ? ="<< ok<<r<<sNum;
					#endif
					//PRIMO CASO: solo coordinate
					if (ok) {
						onlyLat = true;
						bothCoord = false;
						/*Decimal coord. inserted?*/
						if (coDecimal.size()==1)
						{
							convertToDegree(r,0);
							localita.lat = r;
							localita.lon = 0;
							
							getCityFromCo(1);
//							toFade();
							if (support)
		 						 support->setCo(r,0);
						}
						else
						{
						/* GG MM SS coord.*/
						// Estraggo latitudine
						#ifdef DEBUG
						qDebug()<<"SOLO LATITUDINE";
						#endif
						numCo =checkLat(0,s);
						getCityFromCo(numCo);//solo lat
//						toFade();
						
						if (support)
		 						 support->setCity(locValue->text());
						
						}
						
					} else {
						// HO inserito un nome
						
						getCity();
//						toFade();
						onlyLat = false;
						bothCoord = false;
						 
						}
				}
				// LAT LON - suppose that there are numbers
				if (s.size()==2) {
 					qDebug()<<"lat e lon "<<s.size();
					coDecimal1 = s.at(0).split("/");
					coDecimal2 = s.at(1).split("/");

					sNum1 = s.at(0);
					sNum2 = s.at(1);
					sNum1.remove(QChar('/'),Qt::CaseInsensitive);
					sNum2.remove(QChar('/'),Qt::CaseInsensitive);
					double r1 = sNum1.toDouble(&ok1);
					double r2 = sNum2.toDouble(&ok2);
					#ifdef DEBUG
					qDebug()<<"Check lat lon:are numbers?"<<r1<<r2<<(ok1)<<(ok2)<<coDecimal1.size()<<coDecimal2.size();
					#endif
					if (ok1 && ok2) {
						onlyLat   = false;
						bothCoord = true;
						// inputs are numbers		
							if (coDecimal1.size()==1 && coDecimal2.size()==1)
							/* Decimal coordinates */		
							{
								convertToDegree(r1,r2);
								localita.lat = r1;
								localita.lon = r2;
								getCityFromCo(3);						
//								toFade();
		
								if (support)
		 						 support->setCo(r1,r2);
								
							}
							else
							{
								
								numCo = checkLat(0,s);
								numCo +=checkLat(1,s);
								#ifdef DEBUG
								qDebug()<<"NumCo"<<numCo;
								#endif
								getCityFromCo(numCo);
//								toFade();
								if (support)
		 						 support->setCo(localita.lat,localita.lon);
								
							}
					} 
					else
						{
						/* Text inserted */
						getCity();
//						toFade();
						onlyLat = false;
						bothCoord = false;
						wrongCoordinates=true;
						if (support)
							support->setCity(locValue->text());
						}
				}
			
				
	 
		 #ifdef DEBUG
		qDebug()<<"UpdateLat"<<localita.lat<<wrongCoordinates<<"latGradi="<<localita.latGradi<<"latMin="<<localita.latMin<<"latSec="<<localita.latSec;
		#endif
	} else {
		 
		comuneValue->setText("");
		updateComuneLabel(0);
		getCity();
//		toFade();
		wrongCoordinates = true;
		#ifdef DEBUG
		qDebug()<<"I am here, testo vuoto"<<locValue->text();
		#endif
	}
        toFade();
// qDebug()<<"MW from updateLat....";
formatCoordinates();	
}

int MainWindow::checkLat(int mode,const QStringList &s)
{
	/* Check coordinates in GG MM SS*/
	QStringList co; 	
	 
	 
		
	if (mode==0) {
	// UPDATE LAT
	co = s.at(0).split("/");
	#ifdef DEBUG
	qDebug()<<"cerca split.size()="<<co.size();
	#endif
						// SOLO GRADI 
						if (co.size()==1) {
							localita.latGradi = co.at(0).toInt();
							
							localita.latMin = 0;
							localita.latSec = 0;
							convertLat(localita);
							wrongCoordinates = true;
							#ifdef DEBUG
							qDebug()<<"check lat, solo gradi"<<localita.latGradi<<co.at(0);
							#endif
						}
						// SOLO GRADI-MIN
						if (co.size()==2) {
							localita.latGradi = co.at(0).toInt();
							localita.latMin   = co.at(1).toInt();
							localita.latSec = 0;
							convertLat(localita);
							wrongCoordinates = true;
							#ifdef DEBUG
							qDebug()<<"check lat, solo gradi e min"<<localita.latGradi<<localita.latMin<<localita.latSec<<localita.lat;
							#endif
						}
						// GRADI-MIN-SEC
						if (co.size()==3) {
							localita.latGradi = co.at(0).toInt();
							localita.latMin   = co.at(1).toInt();
							localita.latSec   = co.at(2).toInt();
							convertLat(localita);
							wrongCoordinates = false;
							#ifdef DEBUG
							qDebug()<<"check lat, gradi e min,sec"<<localita.latGradi<<localita.latMin<<localita.latSec<<localita.lat; 
							#endif
						}
						if (co.size()>3)
							wrongCoordinates = true;
	}
	if (mode==1) {
	// UPDATE LON
	co = s.at(1).split("/");
						// SOLO GRADI 
						if (co.size()==1) {
							localita.lonGradi = co.at(0).toInt();
							localita.lon = localita.lonGradi;
							wrongCoordinates = true;
						}
						// SOLO GRADI-MIN
						if (co.size()==2) {
							localita.lonGradi = co.at(0).toInt();
							localita.lonMin   = co.at(1).toInt();
							localita.lon      = localita.lonGradi + localita.lonMin/60.0;
							wrongCoordinates = true;
						}
						// GRADI-MIN-SEC
						if (co.size()==3) {
							localita.lonGradi = co.at(0).toInt();
							localita.lonMin   = co.at(1).toInt();
							localita.lonSec   = co.at(2).toInt();
							localita.lon      = localita.lonGradi + localita.lonMin/60.0 + localita.lonSec/3600;
							wrongCoordinates = false;
						}
						if (co.size()>3)
							wrongCoordinates = true;	
	}

formatCoordinates();
return co.size();
}

 

void MainWindow::getCityFromCo(int numCo)
{
	QSqlDatabase d = QSqlDatabase::database();
	QString where;
	if (convertionDone) 
	{
		 
		if ((!wrongCoordinates) && (bothCoord) ){
			  where = QString("WHERE ") + "latitudine_g=" + QString::number(localita.latGradi) +" AND " +
					"latitudine_m=" + QString::number(localita.latMin) +" AND " + 
	  				"latitudine_s=" + QString::number(localita.latSec)   +" AND " +
					"longitudine_g=" + QString::number(localita.lonGradi) + " AND " +
					"longitudine_m=" + QString::number(localita.lonMin)+   " AND " + 
	  				"longitudine_s=" + QString::number(localita.lonSec)  ;
			
	  		
			
		
		} else {
		// Forse ci sono solo coordinate incomplete. Provo a elencare le citta che si avvicinano
			if (numCo==1)
				  where = QString("WHERE ") + "latitudine_g=" + QString::number(localita.latGradi);
			if (numCo==2)
				  where = QString("WHERE") + "latitudine_g=" + QString::number(localita.latGradi) +" AND " +
					QString("latitudine_m=") + QString::number(localita.latMin);
			if (numCo==3)
				  where = QString("WHERE ") + "latitudine_g=" + QString::number(localita.latGradi) +" AND " +
					"latitudine_m=" + QString::number(localita.latMin) +" AND " + 
	  				"latitudine_s=" + QString::number(localita.latSec);
	
	  		 
	  			
		}
			modelRadiazione->setQuery("SELECT * FROM radiazione  " + where);
			#ifdef DEBUG
			qDebug()<<"GetCityFRomCo wronCo="<<wrongCoordinates<<onlyLat<<modelRadiazione->lastError()<<modelRadiazione->query().executedQuery()<<where;
			#endif

			if (modelRadiazione->rowCount()==1) {
					noNameAvailable = false;
					updateFromModel(0);  
					updateComuneLabel(1);
					comuneValue->setText(modelRadiazione->record(0).value("nome").toString());
					
					
			} else {
							noNameAvailable = true;
							comuneValue->setText("");
							//IL diagramma solare si puo' fare comunque
							//set();
							updateComuneLabel(1);
							
			}	

		
	}
}
 

void MainWindow::getCity()
{
	#ifdef DEBUG
    	qDebug()<<"Sto cercando...";
	#endif 
	int count;


	QSqlDatabase d = QSqlDatabase::database();
	QString n = locValue->text().trimmed();
	QStringList list = n.split(",");
	QString name;
	name = list.at(0).trimmed();
	name.replace("'","''");

	// Get the coordinates from the name of the city, if possible
	if (convertionDone) 
	{
		//Find the city; TO DO check on the values
		
		modelRadiazione->setQuery("SELECT * FROM radiazione WHERE nome LIKE '%" + name + "%'");
		// Se ci sono comuni omonimi ? TO DO
	 	count = modelRadiazione->rowCount();
 		if (count>1) {
				
			 
			#ifdef DEBUG	
			qDebug()<<"Some results in getCity"<<modelRadiazione->lastError()<<modelRadiazione->query().executedQuery()<<(modelRadiazione->record(0).value("latitudine_g").toInt())<<count;	
			#endif

			//updateFromModel(0);
  		 	//updateComuneLabel(1);
			// We must choose one city, therefore a null city is a wrong city
			showItalia = true;
			noNameAvailable = true;
			wrongCoordinates = true;
			onlyLat = false;
  			comuneValue->setText("");
			/* If there is a match in the italian database, there is also in google maybe*/
			if (support)
		 		support->setCity(locValue->text() + ",");
		
		} else {
				if (count==0) {
				// Non ho trovato la ocalita
					showItalia = false;
					noNameAvailable = true;	
					wrongCoordinates = true;
					onlyLat = false;
					updateComuneLabel(0);				
					#ifdef DEBUG	
					qDebug()<<"MW GETCITY No results in getCity"<<modelRadiazione->lastError()<<modelRadiazione->query().executedQuery()<<count;
					#endif 
					comuneValue->setText("");
					if (support)
		 						 support->setCity(locValue->text());
				}
			
				if (count==1) {
				// HO trovato la localita posso disegnare
				/* Check if there is an exact match*/
				
				QString temp = modelRadiazione->record(0).value("nome").toString();
					if (temp==name || temp == normalize(name)) 
					{
					noNameAvailable = false;
					updateFromModel(0);
					updateComuneLabel(1);
					#ifdef DEBUG
					qDebug()<<"Un risultato in getCity"<<modelRadiazione->record(0).value("latitudine_g").toString()<<temp<<name<<normalize(name);
					#endif
					comuneValue->setText(modelRadiazione->record(0).value("nome").toString());
					 
					}
					else
					{
					/* We must select the result found to confirm */
					noNameAvailable = true;
					wrongCoordinates = true;
					onlyLat = false;
					comuneValue->setText("");
					#ifdef DEBUG
					qDebug()<<"No exact matching in getCity"<<temp<<name<<normalize(name);
					#endif
					 
					}
					if (support)
		 				 support->setCity(locValue->text() + ", It");
				}
		 
	 
			} 
	 } else  {
		 noNameAvailable = true;
		 }

 
}
bool MainWindow::confirmErase(const QString &c)
{
	QSqlDatabase d = QSqlDatabase::database();
	int r = QMessageBox::question(this,tr("Nuovo database"),tr("Cancello il database precedente?"),QMessageBox::Ok,QMessageBox::Cancel);
		if (r==QMessageBox::Ok) {
				QSqlQuery q(d);
				q.prepare("DELETE FROM " + c);
				
				q.exec();
				#ifdef DEBUG
				qDebug()<<"Erase="<<q.lastError();
				#endif
				return true;
		} else {
				return false;
		}
}
		
//  void MainWindow::setFiltro()
// {   
// 	QString filtro = comuneValue->text();
// 	QRegExp regExp(filtro, Qt::CaseInsensitive,QRegExp::PatternSyntax(QRegExp::FixedString));
//         proxyModel->setFilterRegExp(regExp);
// 
// }
void MainWindow::updateCity(const QModelIndex & m)
{
	QModelIndex source;
	if (m.isValid())
	{
		source =proxyModel->mapToSource(m);
		
		int i = (source.row());//id of the selected city
		// Aggiorno la localita
 		updateFromModel(i);
		
		noNameAvailable = false;
		
		
		updateComuneLabel(1);
    		#ifdef DEBUG
		qDebug()<<"UpdateCity"<<localita.lat<<wrongCoordinates<<"latGradi="<<localita.latGradi<<"latMin="<<localita.latMin<<"latSec="<<localita.latSec<<localita.name<<i;
    		#endif
		wrongCoordinates = false;	
		comuneValue->setText(localita.name);
		/* Since I select from the italian database, tell Google to search in Italy*/
		if (support)
			support->setCity(localita.name + ", It"); 

                set();
		
	}
	else {
		
		noNameAvailable = true;
		wrongCoordinates = false;
	     }
	
}

bool MainWindow::extractRadiazione(loc localita)
{
bool n;
// 	qDebug()<<"Extract radiazione ..mode"<<localita.source;
/* We can also extract temperature and wind files if the user did not edit the temp. table*/
		if (!tempDataIsEdited && !doNotLoadTemp ){
                               findNasaData(localita.lat,localita.lon,localita.latGradi,localita.latMin,localita.latSec,
                                                 localita.lonGradi,localita.lonMin,localita.lonSec,1);//Find Temp Data
// 				tempDaily = t.data;
				adjustVector(tempDaily);
// 				qDebug()<<"MW extract NASA temp SIZE"<<tempDaily.size();
				updateTempWidget( );
		}
		if (!windDataIsEdited && !doNotLoadWind ){
                               findNasaData(localita.lat,localita.lon,localita.latGradi,localita.latMin,localita.latSec,
                                                 localita.lonGradi,localita.lonMin,localita.lonSec,2);//Find Temp Data
// 				windDaily = w.data;
				adjustVector(windDaily);
// 				qDebug()<<"MW extract NASA wind SIZE"<<windDaily.size();
				updateWindWidget( );
		}
switch (localita.source) {
	case radEnea:
	
		// Se il nome non e' disponibile, la localita' non e' presente nell'archivio
		// e bisogna prendere due punti "vicini"
                #ifdef DEBUG
		qDebug()<<"Extract Radiazione...noname?"<<noNameAvailable;
                #endif
		if (!noNameAvailable) {
			QString where = "reg=" + QString::number(localita.reg) +
					" AND prov=" + QString::number(localita.prov) +
					" AND comune=" + QString::number(localita.comune);
			modelRadiazione->setQuery("SELECT * from radiazione WHERE " + where);
			//12 mesi
			#ifdef DEBUG
			qDebug()<<"Num affected"<<modelRadiazione->rowCount()<<modelRadiazione->query().executedQuery();
			#endif
			
			if (modelRadiazione->rowCount()==1) {
				for (int i=0;i<12;i++) {
					Hg[i]=modelRadiazione->record(0).value(i+6).toDouble();
					
  					#ifdef DEBUG
					qDebug()<<"Hg="<< Hg[i];
  					#endif
				}
// 			changeColor(*maxIrrHinclValue,"darkkhaki");
			updateStatusBar("Database","darkkhaki"); 
			return true; 
			
			} else 
				{ 	
					
				}
		} else {
			if (findNear()) {
				
				updateStatusBar(tr("Stimata"),"red"); 
				
				estimatedCoordinates = true;
				return true;
			}
			else
				estimatedCoordinates = false;
				updateStatusBar(tr("Dato mancante"),"red");
// 				 qDebug()<<"MW Extract returned "<<false;
				return false;
			}
		
// 		statusLabel->setText(tr("Sorgente: ") + source.at(localita.source));
	break;
	
	case radCustom:
		/* Controllo se e' stato caricato il databse custom */
		if (!radSourceLoaded()) {	
			QMessageBox::critical(this,tr("Errore Radiazione"),tr("Vuoi usare un database custom ma non lo hai caricato, oppure hai un file corrotto (dati non in 12 mesi). Prova prima a caricarlo"),QMessageBox::Ok);
			resetHg();
			return false;
			}
		/* Carico il database */
		qDebug()<<"Carico il database custom";
		for (int i=0;i<12;i++) 
			/* Convert all in Megajoule because routines use mj as base unit */
			if (localita.radUnit == kwh )
				Hg[i]=customHg.at(i).y()*3.6;
			else
				Hg[i]=customHg.at(i).y()*3.6;
		
		statusLabel->setText(tr("Sorgente") +"("+ QString::number(localita.radUnit)+"):"+sourceRadSettings->getSourceName());
		return true;
	break;

	case radNasa:
                 n = findNasaData(localita.lat,localita.lon,localita.latGradi,localita.latMin,localita.latSec,
                                                localita.lonGradi,localita.lonMin,localita.lonSec,0);//find Rad Data
// 		QPolygonF nasaData = n.data;
// 		qDebug()<<"MW extract:"<<nasaData;
		statusLabel->setText(tr("Sorgente: ") + source.at(localita.source));
		if (nasaData.size()>=12) {
			/* Dati nasa in kwh/m2/day*/
			for(int i=0;i<12;i++){
			Hg[i] = 3.6 * nasaData.at(i);
// 			qDebug()<<"MW extract:"<<i<<nasaData.at(i).y()<<Hg[i];
			}
			
		if (n)
			updateStatusBar("Stimata","red");
		else
			updateStatusBar("Esatto","darkkhaki");

		
		changeColor(*statusLabel,""); 
// 		statusLabelWarning->setText(tr("Rad.: Database"));
// 		changeColor(*statusLabelWarning,"darkkhaki");
		
		
                return true;
		
		} 
		 else {
			qDebug()<<"MW extract NASA:"<<nasaData.size();
			statusLabelWarning->setText(tr("Rad.: Errore"));
			 
			changeColor(*statusLabel,"red"); 
			return false;
		}
	break;
		default:
			return false;
	}	
}

void MainWindow::resetHg()
{
	for (int i=0;i<12;i++)
		Hg[i] = 0;
}
void MainWindow::resetCustomHg()
{
	customHg.resize(0);
	for (int i=0;i<customHg.size();i++){
		customHg.append(QPointF(i,0));
		
	}
}
bool MainWindow::radSourceLoaded()
{
	/* ci servono dodici mesi*/
	if (customHg.size()==12)
		return true;
	else
		return false;
}

bool MainWindow::findNear()
{
	double Hg1[12],Hg2[12];
	double    lat1,lat2,distance,lat,lon,latMed;
	int condition = 1;
	QPolygonF region;
	QVector<int> index;
	 
	// Cerco due punti vicini alle coordinate date
	// Find a region

	modelExtract->setQuery("SELECT id,latitudine_g,latitudine_m,latitudine_s,longitudine_g,longitudine_m,longitudine_s FROM radiazione WHERE	abs(latitudine_g-"+QString::number(localita.latGradi) + ")<2 AND abs(latitudine_m-" + QString::number(localita.latMin) + ")<5 AND abs (latitudine_s-" + QString::number(localita.latSec) + ")<20");
	
	int rSize = modelExtract->rowCount();

	if (rSize==0)	
		condition = -1;
if (condition>0){
	int k=0;
	#ifdef DEBUG
  	qDebug()<<"FINDNEAR"<<modelExtract->query().executedQuery()<<modelExtract->lastError();	
	#endif
	// Get and convert coordinates of the point in the region
	while (k<rSize)
	{
		
		index<<modelExtract->record(k).value("id").toInt();
		 
		lat = MyMath::convertCoFromDegree(modelExtract->record(k).value("latitudine_g").toInt(),
			modelExtract->record(k).value("latitudine_m").toInt(),
			modelExtract->record(k).value("latitudine_s").toInt());
		lon = MyMath::convertCoFromDegree(modelExtract->record(k).value("longitudine_g").toInt(),
			modelExtract->record(k).value("longitudine_m").toInt(),			modelExtract->record(k).value("longitudine_s").toInt());
		region<<QPointF(lat*pi/180,lon*pi/180);
	k++;
	}
	/*Compute distance with arc circle for short distances*/
	/*http://en.wikipedia.org/wiki/Great-circle_distance*/
	/*http://en.wikipedia.org/wiki/Geographical_distance*/

	//First Point
	double minDistance=9999999;
	int firstId = index.at(0);
	for (int i=0; i<rSize;i++) {
		latMed = (pi/180*localita.lat+ region.at(i).x())/2;
		distance = sqrt( pow( (pi/180*localita.lat-region.at(i).x()),2) 
		+ pow( cos(latMed)*(pi/180*localita.lon-region.at(i).y()) ,2));
// 		qDebug()<<"DISTANCES "<<i<<distance<<index.at(i);
		if (distance < minDistance) {
			minDistance = distance;
			firstId = index.at(i);
			}
	}
	#ifdef DEBUG
	qDebug()<<"First point "<<firstId<<index.indexOf(firstId)<<minDistance<<localita.lat<<localita.lon<<region.at(index.indexOf(firstId))<<
	MyMath::degree(region.at(firstId).x());
	qDebug()<<"First point "<<
	MyMath::minute(region.at(firstId).x());
	qDebug()<<"First point "<<
	MyMath::seconds(region.at(firstId).x());
	#endif

	if (minDistance==9999999)
		condition = -1;

	//Second point
	minDistance = 9999999;	
	int secondId = index.at(0);
	for (int i=0; i<rSize;i++) {
		
		latMed = (pi/180*localita.lat+region.at(i).x())/2;
		distance = sqrt(pow((pi/180*localita.lat-region.at(i).x()),2) + pow( cos(latMed)*(pi/180*localita.lon-region.at(i).y()) ,2));
		
		if (distance < minDistance && i!=index.indexOf(firstId)) {
			minDistance = distance;
			secondId = index.at(i);
			}
	}
	#ifdef DEBUG
	qDebug()<<"Second point "<<secondId<<minDistance<<localita.lat<<localita.lon<<region.at(index.indexOf(secondId))<<modelExtract->record(index.indexOf(secondId)).value("nome").toString();
	#endif
	if (minDistance==9999999)
		condition = -1;

 
	
		modelRadiazione2->setQuery("SELECT * from radiazione WHERE id=" + QString::number(firstId));
// 		qDebug()<<"MW FindNear()..."<<localita.lat<<localita.lon;
// 		qDebug()<<"First near city "<<modelRadiazione2->record(0).value("nome").toString();
		lat1 = region.at(index.indexOf(firstId)).x();
		//Copio la radiazione
		for (int i=0;i<12;i++) Hg1[i]=modelRadiazione2->record(0).value(i+6).toDouble();
 
	
		modelRadiazione2->setQuery("SELECT * from radiazione WHERE id=" + QString::number(secondId));
 		qDebug()<<"Second near city "<<modelRadiazione2->record(0).value("nome").toString();
		 //Copio la radiazione
		lat2 = region.at(index.indexOf(secondId)).x();
		for (int i=0;i<12;i++) {
			Hg2[i]=modelRadiazione2->record(0).value(i+6).toDouble();
			Hg[i] = Hg1[i] + (pi/180*localita.lat-lat1)*(Hg2[i]-Hg1[i])*180/pi*(lat1-lat2);
			#ifdef DEBUG
			qDebug()<<"Radiazione stimata ..."<<Hg[i]<<Hg1[i]<<Hg2[i]<<localita.lat<<lat1<<lat2<<firstId<<secondId;
			#endif
		}
}		
	if (condition>0)	
		return true;
	else
		return false;
 

}

//int MainWindow::goodCo(int g,int m,int s)
//{
//	if ((g>=-90 && g<=90)){
//
//		if ( (m>=0 && m<=60) && (s>=0 && s<=60) )
//			{
//// 			qDebug()<<"Good g m s"<<g<<m<<s;
//			return 3;}
//		else
//			if  ((m>=0 && m<=60))
//			{qDebug()<<"Good g m "<<g<<m<<s;
//			return 2;
//			}
//	}
//	else
//		{
//		qDebug()<<"Good g "<<g<<m<<s;
//		return 1;
//		}
//}
void MainWindow::convertLat(loc loca)
{
	
	localita.lat = loca.latGradi + (loca.latMin)/60.0 + (loca.latSec)/3600.0;
	localita.lon = loca.lonGradi + (loca.lonMin)/60.0 + (loca.lonSec)/3600.0;
	 #ifdef DEBUG
	qDebug()<<"lat convertita="<<localita.lat;
	#endif
}

void MainWindow::updateComuneLabel(int reset)
{
	// Inserisco le coordinate
	if (reset==1) {
	comuneLat->setText(QString::number(localita.latGradi) +
							  "<sup>o</sup>" +
							  QString::number(localita.latMin)+
							  "'" +
							  QString::number(localita.latSec)+"''" + " (" +QString::number(localita.lat)+")"+ "<sup>o</sup>");
	comuneLatS->setText(QString::number(localita.lat)+"<sup>o</sup>");
	comuneLon->setText(QString::number(localita.lonGradi) +
							   "<sup>o</sup>" + 
							  QString::number(localita.lonMin)+
							  "'" +
							  QString::number(localita.lonSec)+"''" + " (" + QString::number(localita.lon) +")"+ "<sup>o</sup>");
	comuneLonS->setText(QString::number(localita.lon) + "<sup>o</sup>");

	}
	else
	{
	comuneLat->setText("");
	comuneLatS->setText("");
	comuneLon->setText("");
	comuneLonS->setText("");
	}
}
void MainWindow::updateFromModel(int i)
{
	if (!modelRadiazione->record(i).isEmpty()){
			localita.latGradi =  (modelRadiazione->record(i).value("latitudine_g").toInt());
			localita.latMin =  (modelRadiazione->record(i).value("latitudine_m").toInt());
			localita.latSec =  (modelRadiazione->record(i).value("latitudine_s").toInt());
			localita.lonGradi =  (modelRadiazione->record(i).value("longitudine_g").toInt());
			localita.lonMin = (modelRadiazione->record(i).value("longitudine_m").toInt());
			localita.lonSec = (modelRadiazione->record(i).value("longitudine_s").toInt());
			localita.lat= localita.latGradi + localita.latMin/60.0 + localita.latSec/3600.0;
			localita.lon= localita.lonGradi + localita.lonMin/60.0 + localita.lonSec/3600.0;
	
			localita.reg = modelRadiazione->record(i).value("reg").toInt();
			localita.prov = modelRadiazione->record(i).value("prov").toInt();
 			localita.comune = modelRadiazione->record(i).value("comune").toInt();
	 
			localita.name =modelRadiazione->record(i).value("nome").toString();
//                          qDebug()<<"From model..."<<localita.lat<<localita.latMin<<localita.lonMin;
			formatCoordinates();

        localita.utc = (int)floor((localita.lonGradi+7.5)/15);
	}
}
void MainWindow::setNewCity(const QString &s )
{
	
	 
	localita.azi  = aziValue->value();
	localita.incl = inclValue->value();
	localita.anno = annoValue->value();
	localita.albedo = albedoValue->value();
	 if (!s.isEmpty())
		{
// 		qDebug()<<"MW setNewCity set()";
		set();
		}
	 
}

void MainWindow::createSolarPlot()
{
	 
                localita.utc = (int)floor((localita.lonGradi+7.5)/15);
		localita.alt = altitudeValue->value();
		w->toggleSpline(toggleSplineBox->checkState());

		
                
                w->setIncl(localita.incl);
		w->setUTC(localita.utc);
		w->setAlt(localita.alt);
		w->setAzi(localita.azi);
                /* Double facade?*/
                 w->setCurrentSide(comboCurrentField->currentIndex());
                if (localita.tipo==2)
                    w->setAziIncl2(localita.additionalIncl.at(0),localita.additionalAzi.at(0));


		w->setLong(localita.lon);
		w->setLat(localita.lat);
		w->setYear(localita.anno);
	 	w->setIntegration(1);/* custom integration interval */
                w->setShadowCombineMode(localita.ombreModel);
                #ifdef DEBUG
                qDebug()<<"ombreMode in createsolar"<<localita.ombreModel;
                #endif
	if ((!noNameAvailable) || googleNameAvailable && !googleError && !(onlyLat||bothCoord) ){
//   		qDebug()<<"MW create solar PLOT "<<googleNameAvailable<<noNameAvailable<<googleError<<onlyLat;
		w->setLocName(localita.name);
	}
	else
	   	w->setLocName(localita.coordinates);

  		w->compute();
		w->computeShadow();
                w->toggleSelfShadow(toggleSelfShadowBox->checkState());
  		w->drawMyContents(1);
	myplotpresent=true;
	
 }
void MainWindow::updateOptiLabels(int i)
{
		Hb       = o->getHb( );
		Hho      = o->getHho( );
		Hbh      = o->getHbh( );
		Rb       = o->getRb();
		RbBiAx   = o->getRbBiAx();
		omegaApp = o->getOmegaApp();
		omegaSco = o->getOmegaSco();
		omegasH  = o->getOmegasH();

		if (myplotpresent)
			localita.radDirettaAnnuaTotale= MyMath::cumSumMonthly(Hb,12);
		else
			localita.radDirettaAnnuaTotale= 0;

		if (!noRadiation){
		
		localita.radDirettaAnnuaMedia = MyMath::cumSum(Hb,12)/12;
		maxIrrHbValue->setText(QString("%L1").arg(localita.radDirettaAnnuaTotale));
		
		updateOptiLabel(i);
		}
      		#ifdef DEBUG		
		qDebug()<<"MW updateOptiLabels, lat ="<<localita.lat;
		qDebug()<<"Hb[gennaio]="<<Hb[0]<<"Ho[gennaio]="<<Hho[0]<<"Hbh[gennaio]="<<Hbh[0]<<"Rb[gennaio]="<<Rb[0];
      		#endif
// 		qDebug()<<"MainWindow:: updateOptiLabel"<<o->getUnit()<<Hb[0]<<localita.radDirettaAnnuaTotale;
}
void MainWindow::updateOptiLabel(int i )
{
	if (i<=2)
	{
//   	wattOptiLabel->setText((unit.at(i-1)));
	wattLabel2->setText((unit.at(i-1)));
	}
}	
void MainWindow::createOptimumPlot()
{
	
		o->setLat((localita.lat*pi/180));
		o->setAzi(localita.azi*pi/180);
		if (!noNameAvailable)
			o->setLocName(localita.name);
		else
 			o->setLocName(localita.coordinates);
                o->setIncl(localita.incl*pi/180);/* in radiants */
                o->compute(1,0); // 12 months available here, and also varTilt, i.e. the tilt values of trakers


                o->compute();  // 5 graphs here with different incl
		// Copy the results
		 
//  		o->getAll(*Hb,Hho,Hbh,Rb);
		

// 		qDebug()<<"CreateOptimumPlot...omegaApp[0]"<<omegaApp[0];		
		


	 	o->drawContents(1);
		updateOptiLabels(o->getUnit());

//		updateRadLabel(wattCombo->currentIndex(),maxIrrHbValue,localita.radDirettaAnnuaTotale);

		
}
// void MainWindow::stateChanged(int i)
// {
//     if (i){
//                 inclOptiValue->setEnabled(true);
//                 inclOptiValueOmbre->setEnabled(true);
// 		getOptiIncl();
//             }
//     else{
//         inclOptiValue->setEnabled(false);
//                 inclOptiValueOmbre->setEnabled(false);
//             }
// 
// }
// void MainWindow::getOptiIncl()
// {				
// 	 if (reale->hgIsPresent()) {
// // 				reale->setAll(Rb,Hg,Hho);
// 				reale->setLat(localita.lat);
// // 				reale->setYear(localita.year);
// // 				reale->setIncl(localita.incl);
// 				reale->setAzi(localita.azi);
// 				reale->setR(localita.albedo);
// 				reale->setOmbre(w->getShadowFactor());
// 				reale->setModel(localita.radCorrModel);//UNI
// // 				reale->setAll(Rb,Hg,Hho);
// 				reale->optimize(0);/*optimize without shadow*/
// 				inclOptiValue->setText(QString::number(reale->getBestIncl()));
// 				reale->optimize(1);/* optimize with shdawo*/
// 				inclOptiValueOmbre->setText(QString::number(reale->getBestIncl()));
// 
// 				gain = (noRadiation==false) ? MyMath::cumSumMonthly(reale->getHref(),12) : 0;
// 				gain = 100*(gain - localita.radRealeOmbreAnnuaTotale)/localita.radRealeOmbreAnnuaTotale;
// 				gainValue->setText(QString::number(gain)+" %");
// 	}
// }
double MainWindow::installedPower()
/* In kWp */
{
	int n2;
	int n = numPanels(localita.area);
	if (localita.additionalArea.size()>0)
	   n2 = numPanels(localita.additionalArea.at(0));
	else
		n2 = 0;
	return ((n+n2)* thisProjectPanel.pnom/1000);//in kWp
}
void MainWindow::createEnergyOutPlot()
	/*This function needs the vector HinclOmbre to work */
{
	int n = numPanels(localita.area);
	int n2;
	if (localita.additionalArea.size()>0)
		n2 = numPanels(localita.additionalArea.at(0));
	else
		n2 = 0;
// 	qDebug()<<"MW ENERGYOUT---------AREA"<<localita.additionalArea;
        if (reale && o){
		energyOut->setInstalledPower(installedPower());
		energyOut->setThermalModel(otherLosses.thermalModel);
		energyOut->setYear(localita.anno);
// 		energyOut->setArea(localita.area);
		energyOut->setArea(n *thisProjectPanel.H * thisProjectPanel.L/1000000);
		energyOut->setAddArea(n2 *thisProjectPanel.H * thisProjectPanel.L/1000000);
		
 		energyOut->setPanel(thisProjectPanel);
		energyOut->setInverter(thisProjectInverter);
		#ifdef PLUSVERSION
		if (inverterCheck)
			energyOut->setSystem(inverterCheck->getSystem());
		#endif
		energyOut->setOtherLoss(otherLosses.otherLoss);
 		energyOut->setTempMin(localita.tempMin);
 		energyOut->setTempMax(localita.tempMax);
  		energyOut->setTemp(tempDaily);
                energyOut->setMeanDayLen(o->getMeanDayLen());
		energyOut->setWind(windValue->value());
		energyOut->setWind(windDaily);
		energyOut->setMounting(mountingValue->currentIndex(),mountingHeightValue->value());
		energyOut->setConcRatio(localita.concRatio);
		energyOut->setH(HinclOmbre,HinclOmbre2,reale->getUnit());
		
		
                statusLabelEnergy->setText(energyOut->getStatus());/*this return a string*/
		
		energyOut->computeRealEnergy();
		energyOut->drawContents(1);
	
		energyOutUnit = energyOut->getUnit();
		effTemp   = energyOut->getEffTemp();
		effTemp2   = energyOut->getEffTemp2();

		otherLosses.thermalLosses = effTemp;
		Energy    = energyOut->getRealEnergy();
		totEnergy = energyOut->getTotEnergy();
		otherLosses.totalLossTemp = energyOut->getLossTemp();
		energyPlotPresent = energyOut->getStatus(1); /* this return a bool*/
		localita.starRatio = energyOut->starRatio();
         }
	  
}
QVector<double> MainWindow::computeAlbedo()
{
	QVector<double> a;
	double v,a1,a2;
	/* Model from Jan Remund 2003*/
	if (localita.albedoType > con ){
	
		if (localita.albedoType==variable_low_snow)
			a1 = 0.423; a2 = 0.042;
		if (localita.albedoType==variable_high_snow)
			a1 = 0.618; a2 = 0.044;

			for(int i=0;i<tempDaily.size();i++){
				 v = a1 - a2*tempDaily.at(i);
				 v = (v-0.8)>=0.000000002 ?  0.8 : v;
				 v = (v-0.2)<=0.000000002 ?  0.2 : v;
				 a.append(v);
			}
	return a;
			
	}
	else
		return QVector<double>(1,0);
}
void MainWindow::createRealePlot()
{
	double gain;
 // Radiazione reale
		
			
// 		reale->setIncl(localita.incl);//in degree
		reale->resetOmbre();
		reale->setSource(localita.source);
		reale->setLat(localita.lat);
		reale->setAzi(localita.azi);
		if (localita.albedoType==con )
			reale->setR(QVector<double>(1,localita.albedo));
		if (localita.albedoType > con )
			reale->setR(computeAlbedo());
		 
		
		reale->setYear(localita.anno);
	if (!noNameAvailable)
		reale->setLocName(localita.name);
	else
		reale->setLocName(localita.coordinates);
		reale->setOmegas(omegasH);
		 
		/*Type of system, 1 is biaxial*/
		QPolygonF p;
		switch (localita.tipo){
		default:
		
// 			reale->setAll(Rb,Hho);
			
			p<<QPointF(0,localita.incl*pi/180);
			reale->setIncl(p);

		break;
		case 1:

			reale->setIncl(o->getVarTilt());// varTilt in radiants!/
		break;
		 
		}
		reale->setHg(Hg);
// 		double *tw = w->getShadowFactor();

// 		reale->setOmbre(tw);
		reale->setOmbre(w->getShadowFactor());
		otherLosses.shadows.resize(0);
		 
		/*Double facade?*/
		if (localita.additionalIncl.size()>0 && localita.additionalAzi.size()>0 && localita.tipo==2)
		{
			addOmbre.resize(0);
			addOmegaRb.resize(0);
			 
			reale->resetAdditionalOmbre();
			reale->addInclAzi(localita.additionalIncl,localita.additionalAzi);

			QVector<double> addOmega,addOmegaApp,addOmegaSco,addOmbre;
			for(int s=0;s<localita.additionalIncl.size();s++){
				for(int month=0;month<12;month++){
				addOmega = MyMath::rb(localita.lat*pi/180,localita.additionalIncl.at(s)*pi/180,localita.additionalAzi.at(s),month,localita.anno,0);
// 				addOmega  = MyMath::tiltedRiseSet(localita.additionalIncl.at(s)*pi/180,localita.additionalAzi.at(s)*pi/180,localita.lat *pi/180,month);
// 				
				addOmegaRb<< addOmega.at(0);
				addOmegaApp<< addOmega.at(5);
				addOmegaSco<< addOmega.at(4);
				}
			addOmbre = w->computeShadow(addOmegaApp,addOmegaSco);
 			#ifdef DEBUG
				qDebug()<<"MW double facade..............."<<addOmega<<localita.additionalIncl<<localita.additionalAzi<<addOmbre;
 				#endif 
			reale->addOmbre(addOmbre);
			}
		}

		reale->setModel(localita.radCorrModel);//UNI
	 
 		reale->compute();
		reale->fit();
// 		reale->convertFit();
		otherLosses.shadows = reale->getLossFactors();//In percent		

		/* Plot Ombre*/
		if (checkOmbre->isChecked()){
			reale->drawContents(2,comboCurrentField->currentIndex()+1);/*because Reale wants index from 1 to 2*/
// 			reale->drawDailyContents(2);
		}
		else{
			reale->drawContents(1,comboCurrentField->currentIndex()+1);
// 			reale->drawDailyContents(1);
		}
		
	       
	
		/* Plot daily fitted values */
// 		reale->drawDailyValue(1);
		

               
	
	
		updateRadLabels(reale->getUnit());
 
//   				qDebug()<<"Ottimizzo...";
  				reale->optimize(0);
				inclOptiValue->setText(QString::number(reale->getBestIncl()));

  				reale->optimize(1);/* optimize with shdaow*/
				inclOptiValueOmbre->setText(QString::number(reale->getBestIncl()));
  				reale->computeRefCurve(1,reale->getBestIncl());
				gain = (noRadiation==false) ? MyMath::cumSumMonthly(reale->getHref(),12) : 0;
// 				qDebug()<<"Ottimizzo...end"<<gain;
				gain = 100*(gain - localita.radRealeOmbreAnnuaTotale)/localita.radRealeOmbreAnnuaTotale;
				if (fabs(gain)<0.0000002)
				gainValue->setText("0 %");
				else
				gainValue->setText(QString::number(gain)+" %");
	
//                                 }



		/* Calcolo anche su inseguitore BiAsse */
		
		
                
	 

// if (checkDaily->isChecked())
//	viewDailyRealePlot(Qt::Checked);
//else
//	reale->drawDailyContents(0);

otherLosses.totalShadowLossFactor= reale->getTotalShadowLossFactor();//This is a total yearly loss
otherLosses.meanShadowLossFactor= reale->getLossFactor();// this is the monthly mean of loss factor
		 
}
void MainWindow::drawHourlyValues(){
	//TEST: dati orari
	QPolygonF a,l;
	int m = selectMonth->currentIndex();
	int day = selectDay->currentIndex();
 
	computeHourlyValues(m+1,selectDay->currentIndex()+1);
	otherLosses.scaling = checkScaling->isChecked();
	if (selectMonth->currentIndex()<12){
		hourlyPlot->setMode(otherLosses.scaling,HinclOmbre[m]);
		hourlyEOPlot->setMode(otherLosses.scaling,Energy[selectMonth->currentIndex()]/MyMath::monthEnd(m+1,localita.anno) );
// 		qDebug()<<"MW drawHourly current index"<<selectDay->currentIndex()<<selectMonth->currentIndex()<<hourlyRR<<HinclOmbre[m];
	}
		
	else
		qDebug()<<"MW problem setting the month in HOURLYPLOT"<<selectMonth->currentIndex()<<hourlyRR;
	
	
	hourlyPlot->setHourlyData(hourlyRR);
	hourlyPlot->setTime(m+1,selectDay->currentIndex()+1);

	hourlyEOPlot->setHourlyData(hourlyEO);
	hourlyEOPlot->setTime(m+1,selectDay->currentIndex()+1);
	#ifdef PLUSVERSION
		if (loadInterface){
			l = loadInterface->getHourlyLoads(localita.anno,day+1,m+1);
			hourlyEOPlot->setLoad(l);
			hourlyEOPlot->enableDrawingLoads(checkDrawLoads->isChecked());
// 			qDebug()<<"MW get load "<<l;
		}
	#endif
	
	hourlyPlot->draw(1);
	hourlyEOPlot->draw(1);
}
void MainWindow::changeRealePlots(int state)
{
	/* change the plot between shaded or unshaded data */
// 	qDebug()<<"MW changeRealePlot"<<state;
// 	dailyValuesPresent = false;
	if (state==Qt::Checked) {
	 	reale->drawContents(2,comboCurrentField->currentIndex());
// 		if (checkDaily->isChecked())
// 			reale->drawDailyContents(2);
// 		else
			reale->drawDailyContents(0);
	}
	if (state==Qt::Unchecked){
		
		reale->drawContents(1,comboCurrentField->currentIndex());
// 		if (checkDaily->isChecked())
// 			reale->drawDailyContents(1);
// 		else
			reale->drawDailyContents(0);

	}
}
//void MainWindow::viewDailyRealePlot(int state)
//{
//	if (state==Qt::Checked) {
//		if (!reale->dailyIsDirty())
//			/* We have called compute() and computeDaily() in RR */
//			if (checkOmbre->isChecked())
//				reale->drawDailyContents(1);
//			else
//				reale->drawDailyContents(2);
//		else
//			/* Never generated */
//
//			createDailyRealePlot(Qt::Checked);
//	}
//	else
//		reale->drawDailyContents(0);
//
//}
//void MainWindow::createDailyRealePlot()
//{
//	createDailyRealePlot(checkDaily->checkState());
//}
//void MainWindow::createDailyRealePlot(int state)
//{
//if (checkDaily->isEnabled()) {
//	if (state==Qt::Checked) {
//		if (validForExport){
//			QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
//			/* WARNING this function must be called after createRealePlot() */
//			o->setYear(localita.anno);
//			o->computeDailyRad();
//			dailyValuesPresent = true;
//			/*Type of system, 1 is biaxial*/
//				if (localita.tipo==0){
//					QPolygonF p;
//					p<<QPointF(0,localita.incl*pi/180);
//					reale->setDailyIncl(p);
//					reale->setRbDaily(o->getRbDaily());
//				}
//				else{
//					reale->setDailyIncl(o->getVarTilt());
//					reale->setRbDaily(o->getRbBiAxDaily());
//				}
//				w->setDailyOmegaApp(o->getDailyOmegaApp());// o gives degree here*/
//					w->setDailyOmegaSco(o->getDailyOmegaSco());
//					w->setYear(localita.anno);
//					w->computeDaily();
//					reale->setOmbreFactorDaily(w->getDailyShadowFactor());
//					reale->setOmegasDaily(o->getOmegasHDaily());
//					reale->setHhoDaily(o->getHhoDaily());
//					reale->setYear(localita.anno);
//					reale->computeDaily();
//				if (checkOmbre->isChecked())
//					reale->drawDailyContents(2);	
//				else
//					reale->drawDailyContents(1);	
//				
//			QApplication::restoreOverrideCursor();		
//				
//				
//			}		
//	}
//	else
//		reale->drawDailyContents(0);
//}
//	else 
//		checkDaily->setEnabled(true);
//}
void MainWindow::updateRadLabels(int i )
{
	/* i is the unit */
	/* if mode==0 no rad is available */
	double* hToShow,*hOmbreToShow;
	
        Hincl 	   = reale->getHincl(1);
        HinclOmbre = reale->getHinclOmbre(1);
	Hincl2	   = reale->getHincl(2);
	HinclOmbre2	   = reale->getHinclOmbre(2);

	if (comboCurrentField->currentIndex()==1){
		hToShow = Hincl2;
		hOmbreToShow = HinclOmbre2;
	}
	else{
		hToShow = Hincl;
		hOmbreToShow = HinclOmbre;
	}

	
        
        localita.radRealeAnnuaTotale = (noRadiation==false) ? MyMath::cumSumMonthly(hToShow,12) : 0;
        localita.radRealeAnnuaMedia  = (noRadiation==false) ? MyMath::cumSum(hToShow,12)/12 : 0;
        localita.radRealeOmbreAnnuaTotale = (noRadiation==false) ? MyMath::cumSumMonthly(hOmbreToShow,12) : 0;
//  	qDebug()<<"MW HinclOmbre tot"<< localita.radDirettaAnnuaTotale;

        maxIrrHbValue->setText(QString("%L1").arg(localita.radDirettaAnnuaTotale));
        maxIrrHinclValue->setText(QString("%L1").arg(localita.radRealeAnnuaTotale));
        maxIrrHinclOmbreValue->setText(QString("%L1").arg(localita.radRealeOmbreAnnuaTotale ));
	meanIrrHinclValue->setText(QString("%L1").arg(localita.radRealeAnnuaMedia));
	

// 	if (checkDaily->isChecked())
// 			reale->drawDailyContents(1);
// 		else
// 			reale->drawDailyContents(0);
	
        updateRadLabel(i);
}
void MainWindow::updateRadLabel(int i)
{

        if (i<=2) {

//         wattLabel->setText(unit.at(i-1));
 	wattLabel2->setText(unit.at(i-1) );
// 	wattLabel3->setText(unit.at(i-1)+"/"+tr("giorno"));
        }


}
void MainWindow::changeColor( QLabel &s, const QString &color)
{	
	QPalette palette;
	palette.setColor(QPalette::Active,QPalette::Window,QColor(color));
		s.setPalette(palette);	
        //qDebug()<<"Colore.."<<s.palette()<<color;
}

void MainWindow::createTab()
{
    	/* ATTENTION :This function must be called after createInterface!!! */
	/* because we need tabWidget */
	
        myPlotWidget = new QWidget;
        QVBoxLayout *solarLayout = new QVBoxLayout;
        w = new MyPlot(myPlotWidget);

        w->setHSteps(1,23,0.2);
        w->setLong(13);
        w->setLat(42 + 10.0/60 + 0.0);
        w->setAlt(1);
        w->setUTC(1);
        w->setMode(0);//exact values
        w->setIntegration(integrationType);
        w->setRes(0);
        w->setYear(2009);
        connect(w,SIGNAL(ombreChanged()),this,SLOT(ombreChanged()));

	toggleSplineBox = new QCheckBox(tr("Interpolazione (grafica fine)"));
	toggleSelfShadowBox = new QCheckBox(tr("Visualizza variazione dell'alba-tramonto dovuta al tilt"));
	connect(toggleSplineBox,SIGNAL(stateChanged(int)),w,SLOT(toggleSpline(int)));
	connect(toggleSelfShadowBox,SIGNAL(stateChanged(int)),w,SLOT(toggleSelfShadow(int)));
	
        solarLayout->addWidget(w);
	solarLayout->addWidget(toggleSplineBox);
	solarLayout->addWidget(toggleSelfShadowBox);

//         updateButton = new QPushButton(tr("Aggiorna"));
//         connect(updateButton,SIGNAL(clicked()),SLOT(setDampOthers()));
//         solarLayout->addWidget(updateButton);
        myPlotWidget->setLayout(solarLayout);
        tabWidget->addTab(myPlotWidget,tr("Diagramma Solare"));

        optiWidget = new QWidget;
	optiWidget->setWindowIcon(QIcon(":/images/opti2.png"));
        QVBoxLayout *v = new QVBoxLayout;

        o = new OptimumPlot(optiWidget);
        o->setLat(localita.lat);
        o->setIncl(inclValue->text().toDouble());
        o->setAzi(aziValue->text().toDouble()*pi/180);
        aziValue->setValue(0);
	connect(o,SIGNAL(unitChanged(int)),SLOT(updateOptiLabels(int)));

        v->addWidget(o);
        optiWidget->setLayout(v);
//         tabWidget->addTab(optiWidget,tr("Radiazione e tilt"));

	QTabWidget* innerTab   = new QTabWidget;
	hourlyPlot 	       = new HourlyPlot(this);
	
	checkScaling           = new QCheckBox(tr("Abilita lo scaling automatico"));
	checkScaling->setToolTip(tr("<p>Lo scaling moltiplica tutti i valori orari per un fattore tale che la somma oraria coincide con la media mensile giornaliera. Questo opzione va usata con cautela.</p>"));
	connect(checkScaling,SIGNAL(stateChanged(int)),SLOT(enableScaling(int)));

        realeWidget = new QWidget;
        realeToolWidget = new QWidget;
        QGridLayout *vr = new QGridLayout;
	QVBoxLayout *vr2 = new QVBoxLayout;
// 	QHBoxLayout *hr2 = new QHBoxLayout;
        QGridLayout *gr  = new QGridLayout;
        reale = new RadiazioneReale(realeWidget);
	connect(wattLabel2,SIGNAL(clicked()),reale,SLOT(swapUnit()));
	connect(wattLabel2,SIGNAL(clicked()),o,SLOT(swapUnit()));
// 	connect(wattLabel3,SIGNAL(clicked()),reale,SLOT(swapUnit()));
// 	connect(wattLabel,SIGNAL(clicked()),reale,SLOT(swapUnit()));




// 	checkDaily = new QCheckBox(tr("Genera dati giornalieri"));
// 	checkDaily->setVisible(false); // Not very useful. Kept for future versions.
// 	checkDaily->setCheckState(Qt::Unchecked);
// 	checkDaily->setEnabled(false);

//	currentFieldLabel = new QLabel(tr("Falda corrente"));
        comboCurrentField = new QComboBox;
	comboCurrentField->addItem("1");
        connect(comboCurrentField,SIGNAL(currentIndexChanged(int)),SLOT(redrawSelfShadow(int)));
	connect(comboCurrentField,SIGNAL(currentIndexChanged(int)),SLOT(redrawReale(int)));
	

        checkOmbre = new QCheckBox(tr("Visualizza radiazione incidente senza ombre"));
	checkOmbre->setCheckState(Qt::Unchecked);
  	connect(checkOmbre,SIGNAL(stateChanged(int)),SLOT(changeRealePlots(int)));
//	connect(checkDaily,SIGNAL(stateChanged(int)),SLOT(viewDailyRealePlot(int)));
//	connect(reale,SIGNAL(computeDone()),SLOT(createDailyRealePlot()));
// 	connect(hourlyPlot,SIGNAL(unitChanged(int)),SLOT(),updateHourlyPlot
 
        vr->addWidget(reale,0,0,1,4);
 
 	vr->addWidget(checkOmbre,1,0,1,1);
// 	vr->addItem(QSpacerItem(20,10),1,1,1,1);
//	vr->addWidget(currentFieldLabel,1,2,1,1);
//	vr->addWidget(comboCurrentField,1,3,1,1);

	QGroupBox *group = new QGroupBox(tr("Tilt ottimo"));
	group->setStyleSheet(QString::fromUtf8("QGroupBox {\n"
"     background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n"
"                                       stop: 0 #E0E0E0, stop: 1 #FFFFFF);\n"
"     border: 2px solid gray;\n"
"     border-radius: 5px;\n"
"     margin-top: 1ex;  \n"
" }\n"
"QGroupBox::title {\n"
"     subcontrol-origin: margin;\n"
"     subcontrol-position: top left; /* position at the top center */\n"
"     padding: 0 1px;\n"
 
" }"));
	QGridLayout *gridGroup = new QGridLayout;
	
	tiltButton = new QPushButton(tr("Visualizza"));
	tiltButton->setSizePolicy(QSizePolicy(QSizePolicy::Minimum,QSizePolicy::Fixed));
	tiltButton->setMinimumSize(QSize(100,tiltButton->minimumSizeHint().height()));
	
	connect(tiltButton,SIGNAL(clicked()),SLOT(drawRefCurve()));
	
//         gr->addWidget(inclOptiCheck,0,0,1,1);	
// 	QLabel *iol = new QLabel(tr("Tilt ottimo"));	
	gainLabel = new QLabel(tr("Guadagno"));
	gainLabel->setToolTip(tr("Guadagno del sistema fisso con tilt ottimo rispetto al sistema impostato"));
	gainValue = new QLabel("");
        
	gridGroup->addWidget(inclOptiLabel,0,0,1,1);
        gridGroup->addWidget(inclOptiValue,0,1,1,2);
	gridGroup->addWidget(tiltButton,0,3,1,1);
        gridGroup->addWidget(inclOptiOmbreLabel,1,0,1,1);
        gridGroup->addWidget(inclOptiValueOmbre,1,1,1,2);
	gridGroup->addWidget(gainLabel,1,3,1,1);
	gridGroup->addWidget(gainValue,1,4,1,1);
	gridGroup->setColumnStretch(5,3);
	group->setLayout(gridGroup);

        gr->addWidget(maxIrrHb,0,0,1,1);
        gr->addWidget(maxIrrHbValue,0,1,1,1);
// 	gr->addWidget(wattOptiLabel,0,2,1,1);
	gr->addWidget(maxIrrHincl,0,2,1,1);
        gr->addWidget(maxIrrHinclValue,0,3,1,1);
//         gr->addWidget(wattLabel,0,5,1,1);

        gr->addWidget(meanIrrHincl,1,0,1,1);
        gr->addWidget(meanIrrHinclValue,1,1,1,1);
//         gr->addWidget(wattLabel3,1,2,1,1);
        gr->addWidget(maxIrrHinclOmbre,1,2,1,1);
        gr->addWidget(maxIrrHinclOmbreValue,1,3,1,1);
        gr->addWidget(wattLabel2,1,4,1,1);
        realeToolWidget->setLayout(gr);
  	vr->addWidget(group,2,0,1,4);
         vr->addWidget(realeToolWidget,3,0,1,4);
        realeWidget->setLayout(vr);

// 	selectMonth = new QComboBox;
// 	QLabel *monthLabel  = new QLabel(tr("Mese"));
// 	QLabel *dayLabel    = new QLabel(tr("Giorno"));
// 	selectDay   = new QComboBox;
// 	
// 	selectMonth->addItems(MyMath::stringSerie(1,12));
// 	selectDay->addItems(MyMath::stringSerie(1,MyMath::monthEnd(1,localita.anno)));
// 	connect(selectMonth,SIGNAL(currentIndexChanged(int)),SLOT(changeDays(int)));
// 	connect(selectDay,SIGNAL(currentIndexChanged(int)),SLOT(dayChanged(int)));

   	vr2->addWidget(hourlyPlot);
	vr2->addWidget(checkScaling);
// 	hr2->addWidget(monthLabel);
// 	hr2->addWidget(selectMonth);
// 	hr2->addWidget(dayLabel);
// 	hr2->addWidget(selectDay);
// 	vr2->addLayout(hr2);
	
	QWidget* innerWidget = new QWidget;
	innerWidget->setLayout(vr2);
	
	innerTab->addTab(realeWidget,tr("Radiazione mensile"));
	innerTab->addTab(innerWidget,tr("Radiazione oraria"));
	
        tabWidget->addTab(innerTab,tr("Radiazione reale"));
	

        connect(reale,SIGNAL(unitChanged(int)),SLOT(updateRadLabels(int)));

	QTabWidget* innerTabEO   = new QTabWidget;
	hourlyEOPlot 	         = new HourlyEnergyPlot(this);


	#ifdef PLUSVERSION
	
	 lv = new QVBoxLayout;
	QWidget* lvw    = new QWidget;
	checkDrawLoads =  new QCheckBox(tr("Visualizza carichi elettrici del mese corrente"));
	checkDrawLoads->setToolTip(tr("<p>Puoi cambiare i carichi elettrici dal menu Strumenti</p>"));
	connect(checkDrawLoads,SIGNAL(stateChanged(int)),SLOT(enableDrawingLoads()));

 	QWidget* energySummaryWidget = new QWidget;
	QScrollArea* stext = new QScrollArea;
	stext->setWidgetResizable(true);
	
 	energySummary		 = new QTextEdit;
	energySummary->setReadOnly(true);
	stext->setWidget(energySummary);
  	ves = new QVBoxLayout;
 	ves->addWidget(stext);
	energySummaryWidget->setLayout(ves);
	
	#endif
	energyWidget = new QWidget;
	QWidget *belowWidget = new QWidget;

	QGridLayout *ve = new QGridLayout;
	energyOut = new EnergyOut(energyWidget);
	connect(energyOut,SIGNAL(unitChanged()),SLOT(updateEnergyUnit()));
	
	QHBoxLayout *he = new QHBoxLayout;
	pushMonthly = new QPushButton(tr("Altre perdite mensili "));
	
// 	QWidget* nn = new QWidget;
	monthlyLoss = new MagicTable;	
  	connect(pushMonthly,SIGNAL(clicked()),SLOT(viewMonthlyLoss()));
	QLabel *otherLossLabel = new QLabel;
	otherLossLabel->setText(tr("Perdite mensili (media)"));
	otherLoss = new QLabel;
	
// 	connect(otherLoss,SIGNAL(editingFinished()),SLOT(updatePower()));
 	he->addWidget(otherLossLabel);
 	he->addWidget(otherLoss);
	he->addWidget(pushMonthly);
	belowWidget->setLayout(he);
	
	ve->addWidget(energyOut,0,0,1,1);
	ve->addWidget(belowWidget,1,0,1,1);

	energyWidget->setLayout(ve);
	innerTabEO->addTab(energyWidget,tr("Energia mensile"));

	#ifdef PLUSVERSION
		lv->addWidget(hourlyEOPlot);
		lv->addWidget(checkDrawLoads);
		
		lvw->setLayout(lv);
		innerTabEO->addTab(lvw,tr("Energia oraria"));
		innerTabEO->addTab(energySummaryWidget,tr("Esploso En. oraria"));
				innerTabEO->addTab(energySummaryWidget,tr("Esploso En. oraria"));
	#else
		innerTabEO->addTab(hourlyEOPlot,tr("Energia oraria"));

	#endif
		
          tabWidget->addTab(innerTabEO,tr("Energia elettrica"));

	/* Add economical valution widget*/
	QWidget* cashWidget = new QWidget;
 	cash   = new CashFlowPlot();
	toggleInterest = new QCheckBox(tr("Visualizza rata mutuo"),this);
	connect(toggleInterest,SIGNAL(stateChanged(int)),SLOT(drawInterest(int)));
	QVBoxLayout* vc = new QVBoxLayout;
	vc->addWidget(cash);
	vc->addWidget(toggleInterest);
	cashWidget->setLayout(vc);
	
#ifdef PLUSVERSION	 
  	tabWidget->addTab(cashWidget,tr("Valutazioni economiche"));
	
	tabWidget->addTab(inverterCheck,tr("Check sistema"));
#endif
	
    }
void MainWindow::makeDirty()
{
// 	qDebug()<<"MW project is Dirty";
	projectIsDirty = true;
	
}
void MainWindow::createInterface()
{
#ifdef PLUSVERSION
	inverterCheck = new InverterCheck(this);
	
	
        ecoVal = new EcoVal();
        ecoVal->setProjectFolder(projectName);
	 
	 connect(ecoVal,SIGNAL(isDirty()),this,SLOT(makeDirty()));
	 connect(inverterCheck,SIGNAL(componentStatus( )),SLOT(updateComponentStatus()));
	 
	 loadInterface = new Load;
	 connect(loadInterface,SIGNAL(updated()),SLOT(getLoad()));
#endif
	 
//   	 loadInterface->setDefault();
//  	 loadInterface->show();

	 QGridLayout *mainH = new QGridLayout;

         tabWidget = new QTabWidget;
         tabWidget->setTabPosition(QTabWidget::West);
    	
	 
	mainSettings = new QWidget;
  	mainSettings->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Expanding);
 	mainSettings->setGeometry(QRect(0,0,241,281));

 	leftLayout = new QGridLayout;
//  	leftLayout->setSizeConstraint(QLayout::SetMinimumSize);

	annoLabel = new QLabel;
        annoLabel->setText(tr("Anno"));

	annoValue = new QSpinBox;	
	annoValue->setMinimum(2008);
	annoValue->setMaximum(3000);
	annoValue->setValue(currentDate.year());
// 	utcLabel = new QLabel;
// 	utcLabel->setText(tr("UTC"));
// 	utcValue = new QSpinBox;
// 	utcValue->setMinimum(-12);
// 	utcValue->setMaximum(12);	
// 	utcValue->setValue(1);
 	connect(annoValue,SIGNAL(valueChanged(int)),SLOT(changeDays()));

	altitudeLabel = new QLabel;
	altitudeLabel->setText(tr("Altitudine"));
	altitudeValue = new QDoubleSpinBox;
	altitudeValue->setMinimum(-100);
	altitudeValue->setMaximum(10000);
// 	altitudeValue->setText(QString::number(localita.alt));
	connect(altitudeValue,SIGNAL(editingFinished()),SLOT(createSolarPlot()));

	selectMonth = new QComboBox;
//	QLabel *monthLabel  = new QLabel(tr("Mese"));
	QLabel *dayLabel    = new QLabel(tr("Giorno"));
	
	
	selectDay   = new QComboBox;
	
// 	qDebug()<<"MW currentdate"<<currentDate.day()<<currentDate.month();
	selectMonth->addItems(MyMath::stringSerie(1,12));
	selectDay->addItems(MyMath::stringSerie(1,MyMath::monthEnd(1,localita.anno)));
	selectDay->setCurrentIndex((currentDate.day())-1);
	selectMonth->setCurrentIndex((currentDate.month()-1));
	connect(selectMonth,SIGNAL(currentIndexChanged(int)),SLOT(changeDays()));
 	connect(selectDay,SIGNAL(currentIndexChanged(int)),SLOT(dayChanged(int)));
		
	locLabel = new QLabel;
	locLabel->setText(tr("Cerca"));
	
	QFont font;
	font.setItalic(true);
	locLabelEx = new QLabel;	
	locLabelEx->setFont(font);
	locLabelEx->setText(tr("es.: 40/20/11,14/10/1 oppure 41.14,14.20 oppure Roma, It"));
// 	locLabelEx->setWordWrap(true);
	locValue = new QLineEdit;
		
	 connect(locValue,SIGNAL(returnPressed()),this,SLOT(setDamp()));
 
	italiaData = new QGroupBox(tr("Database Italia"),this);
//  	italiaData->setVisible(false);
	pagesWidget = new QStackedWidget;
	pagesWidget->addWidget(new QWidget);
	connect(pagesWidget,SIGNAL(currentChanged(int)),SLOT(fadeInWidget(int)));

	italiaData->setStyleSheet(QString::fromUtf8("QGroupBox {\n"
"     background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n"
"                                       stop: 0 #E0E0E0, stop: 1 #FFFFFF);\n"
"     border: 2px solid gray;\n"
"     border-radius: 5px;\n"
"     margin-top: 2ex;  \n"
" }\n"
"QGroupBox::title {\n"
"     subcontrol-origin: margin;\n"
"     subcontrol-position: top left; /* position at the top center */\n"
"     padding: 0 3px;\n"
 
" }"));
	comuneLabel = new QLabel;
	comuneLabel->setText(tr("Comune"));
	comuneValue = new QLineEdit;
	comuneValue->setReadOnly(true);

	latLabel     = new QLabel;
	latLabel->setText(tr("Lat."));
	lonLabel     = new QLabel;
	lonLabel->setText(tr("Lon."));

	comuneLat    = new QLabel;
	comuneLat->setTextInteractionFlags(Qt::TextSelectableByMouse);
	comuneLon    = new QLabel;
	comuneLon->setTextInteractionFlags(Qt::TextSelectableByMouse);
	comuneLatS   = new QLabel;
	comuneLatS->setTextInteractionFlags(Qt::TextSelectableByMouse);
	comuneLonS   = new QLabel;
	comuneLonS->setTextInteractionFlags(Qt::TextSelectableByMouse);
	 
	comuniViewLabel = new QLabel;
	comuniViewLabel->setText(tr("Database"));
	comuniView = new QListView;
	comuniView->setLayoutMode(QListView::Batched);
	comuniView->setGeometry(0,0,italiaData->frameGeometry().width(),10);
	comuniView->setBatchSize(10);	
//  	connect(comuneValue,SIGNAL(textChanged(const QString &)),this,SLOT(setNewCity(const QString)));
	connect(comuniView,SIGNAL(doubleClicked(const QModelIndex &)),this,SLOT(updateCity(const QModelIndex &)));

	topLayout = new QGridLayout;
	topLayout->addWidget(comuneLabel,0,0,1,1);
	topLayout->addWidget(comuneValue,0,1,1,1);
	topLayout->addWidget(comuniViewLabel,2,0,1,1);
	topLayout->addWidget(comuniView,2,1,1,2);
	italiaData->setLayout(topLayout);
	pagesWidget->addWidget(italiaData);
	pagesWidget->setCurrentIndex(0);

	 support= new Support(this);
        connect(support,SIGNAL(coordinatesValid()),SLOT(reloadCoordinates()));
        connect(support,SIGNAL(pointChanged(double,double,QString&)),SLOT(updateLatFromGoogle(double,double,QString&)));

// 	QWidget *dateWidget = new QWidget;
// 	QHBoxLayout *hh = new QHBoxLayout;
// 	hh->addWidget(annoLabel);
// 	hh->addWidget(annoValue);
// 	hh->addWidget(monthLabel);
// 	hh->addWidget(selectMonth);
// 	hh->addWidget(dayLabel);
// 	hh->addWidget(selectDay);
// 	dateWidget->setLayout(hh);
	
	leftLayout->addWidget(locLabel,0,0,1,1);
	leftLayout->addWidget(locValue,0,1,1,1);
	leftLayout->addWidget(locLabelEx,1,0,1,2);
//  	leftLayout->addWidget(comuneLabel,2,0,1,1);
// 	leftLayout->addWidget(comuneValue,2,1,1,1);
	leftLayout->addWidget(latLabel,2,0,1,1);
	leftLayout->addWidget(comuneLat,2,1,1,1);
// 	leftLayout->addWidget(comuneLatS,2,2,1,1);
	leftLayout->addWidget(lonLabel,3,0,1,1);
	leftLayout->addWidget(comuneLon,3,1,1,2);
//   	leftLayout->addWidget(comuneLonS,3,2,1,2);
// 	leftLayout->addWidget(annoLabel,4,0,1,1);
//   	leftLayout->addWidget(annoValue,4,1,1,1);
// 	leftLayout->addWidget(dateWidget,4,2,1,1);
 	leftLayout->addWidget(altitudeLabel,4,0,1,1);
  	leftLayout->addWidget(altitudeValue,4,1,1,2);
   	leftLayout->addWidget(pagesWidget,5,0,1,2);
// 	leftLayout->addWidget(comuniViewLabel,5,0,1,1);
// 	leftLayout->addWidget(comuniView,5,1,1,2);

  	 leftLayout->addWidget(support,6,0,1,3);
	
	
	
	
// 	leftLayout->addWidget(monthLabel,6,2,1,1);
// 	leftLayout->addWidget(selectMonth,6,3,1,1);
// 	leftLayout->addWidget(dayLabel,6,4,1,1);
// 	leftLayout->addWidget(selectDay,6,5,1,1);
	
// 	leftLayout->addWidget(utcLabel,8,0,1,1);
// 	leftLayout->addWidget(utcValue,8,1,1,1);
//    	leftLayout->setColumnStretch(2, 10 );
 	mainSettings->setLayout(leftLayout);
	
 	 

 
	
	QGridLayout *surfaceLayout = new QGridLayout;

	aziValue = new QDoubleSpinBox(mainSettings);
	aziValue2 = new QDoubleSpinBox(mainSettings);
	
	aziValue->setMinimum(-180);
	aziValue->setMaximum(180);
	aziValue->setReadOnly(false);
	aziValue2->setMinimum(-180);
	aziValue2->setMaximum(180);
	aziValue2->setReadOnly(false);
	aziValue2->setVisible(false);
// 	azi->setMinimumWidth(2);
	azi = new QLabel;
	azi->setText(tr("Azimuth(SO)"));
        azi->setToolTip(tr("<p>Azimuth misurato rispetto a SUD <br> positivo verso OVEST</p>"));
	connect(aziValue,SIGNAL(editingFinished()),this,SLOT(setDampOthers()));
	connect(aziValue,SIGNAL(valueChanged(double)),this,SLOT(updateSurface(double)));
	
	connect(aziValue2,SIGNAL(editingFinished()),this,SLOT(setDampOthers()));
	connect(aziValue2,SIGNAL(valueChanged(double)),this,SLOT(updateSurface(double)));

	incl = new QLabel;
	incl->setText(tr("Tilt (gradi)"));
	inclValue = new QDoubleSpinBox ;
	inclValue->setMinimum(0);
	inclValue->setMaximum(180);
	inclValue->setReadOnly(false);

	inclValue2 = new QDoubleSpinBox ;
	inclValue2->setMinimum(0);
	inclValue2->setMaximum(180);
	inclValue2->setReadOnly(false);
	inclValue2->setVisible(false);

	albedoLabel = new QLabel(mainSettings);	
	albedoLabel->setText(tr("Coeff. di albedo"));
	albedoValue = new QDoubleSpinBox(mainSettings);
	albedoValue->setMinimum(0);
	albedoValue->setMaximum(1);
	albedoValue->setSingleStep(0.01);
	albedoValue->setReadOnly(false);
 
	connect(albedoValue,SIGNAL(editingFinished()),this,SLOT(setDampOthers()));
	connect(inclValue,SIGNAL(editingFinished()),this,SLOT(setDampOthers()));
	connect(inclValue,SIGNAL(valueChanged(double)),this,SLOT(updateTiltSurface(double)));
	connect(inclValue,SIGNAL(valueChanged(double)),SLOT(updateLimitDistance(double)));

	connect(inclValue2,SIGNAL(editingFinished()),this,SLOT(setDampOthers()));
	connect(inclValue2,SIGNAL(valueChanged(double)),this,SLOT(updateTiltSurface(double)));
	

	areaLabel = new QLabel;
	areaLabel->setText(tr("Area(mq)"));
	areaValue = new QDoubleSpinBox;
        areaValue->setRange(0,1000000);
	areaValue2 = new QDoubleSpinBox;
        areaValue2->setRange(0,1000000);
	areaValue2->setVisible(false);
	connect(areaValue,SIGNAL(editingFinished()),SLOT(updatePower()));
	connect(areaValue,SIGNAL(valueChanged(double)),SLOT(changeNumPanels(double)));
	
	connect(areaValue2,SIGNAL(editingFinished()),SLOT(updatePower()));
	connect(areaValue2,SIGNAL(valueChanged(double)),SLOT(changeNumPanels2(double)));

	numOfPanels 	= new QLabel(tr("Numero di pannelli"));
	numOfPanelsValue= new QLabel;
	numOfPanelsValue->setTextInteractionFlags(Qt::TextSelectableByMouse);

	numOfPanelsValue2= new QLabel;
	numOfPanelsValue2->setTextInteractionFlags(Qt::TextSelectableByMouse);
	numOfPanelsValue2->setVisible(false);

	limitDistanceLabel    = new QLabel(tr("<p>Distanza limite <i>a</i> (mm)<p>"));
	limitDistanceLabel->setWordWrap(true);
	trackDim    = new QLabel(tr("<p>Larghezza tracker (m)<p>"));
	trackDim->setWordWrap(true);
	trackDimValue = new QDoubleSpinBox;
	trackDimValue->setMinimum(0);
	trackDimValue->setVisible(false);
	trackDim->setVisible(false);
	connect(trackDimValue,SIGNAL(valueChanged(double)),SLOT(updateLimitDistance(double)));
	limitDistanceLabel->setToolTip(tr("<p>In caso di disposizione in file, questo valore rappresenta la distanza fra file di pannelli che evita l'autombreggiamento. Il calcolo considera un angolo di elevazione del sole alle ore 10:00 del mese pi&ugrave; basso. <u>Con tilt nullo, tale distanza &egrave; nulla.</u><p>"));
	limitDistanceValue    = new QLabel;
	limitDistanceValue->setTextInteractionFlags(Qt::TextSelectableByMouse);
	

	 mountingLabel = new QLabel(tr("Tipo installazione"));
	 mountingValue = new QComboBox;
	 mountingValue->addItems(QStringList()<<tr("Su guida")<<tr("BIPV")<<tr("Schiera"));
	 mountingValue->setCurrentIndex(rack);
	 mountingHeightLabel = new QLabel(tr("<p>Altezza palo <i>h</i> (m)<p>"));
	 mountingHeightValue = new QDoubleSpinBox;
	 mountingHeightValue->setMinimum(0);
	 mountingHeightValue->setMaximum(50);
	 mountingHeightValue->setValue(2.5);
	 mountingHeightValue->setEnabled(false);
	 
        concRatioLabel = new QLabel(tr("Fattore di concentrazione"));
  	concRatioValue = new QDoubleSpinBox;
	concRatioValue->setMinimum(1);
	concRatioValue->setMaximum(1000);
	concRatioValue->setValue(1.0);

// 	QLabel *l=new QLabel(tr("Premi CTRL+I per altre opzioni o clicca qui"));
// 	QLabel *l2=new QLabel(tr("Premi CTRL+I per altre opzioni o clicca qui"));
// 	QWidget *t=new QWidget(this);
// 	QHBoxLayout *htl = new QHBoxLayout;
// 	htl->addWidget(l);
// 	htl->addWidget(l2);
// 	t->setLayout(htl);
// 
//   	bF = new FaderWidget(t);
// 	
// 	bF->show();
// 	QPushButton *bF = new QPushButton(this);
	
	
	connect(mountingValue,SIGNAL(currentIndexChanged(int)),SLOT(enableHeight(int)));
	connect(mountingHeightValue,SIGNAL(editingFinished()),SLOT(updatePower()));
	connect(mountingHeightValue,SIGNAL(valueChanged(double)),SLOT(updateLimitDistance()));
	connect(concRatioValue,SIGNAL(editingFinished()),SLOT(updatePower()));
// 	drawSurface(canvas,0); // Initially the surface is at 0 degree SW*?
	 canvas = new SurfaceWidget ;
	connect(canvas,SIGNAL(swapped(double)),SLOT(updateLimitDistance()));
	connect(mountingValue,SIGNAL(currentIndexChanged(int)),canvas,SLOT(setType(int)));
	surfaceLayout->addWidget(azi,0,0,1,1);
	surfaceLayout->addWidget(aziValue,0,1,1,1);
	surfaceLayout->addWidget(aziValue2,0,2,1,1);
	surfaceLayout->addWidget(incl,1,0,1,1);
	surfaceLayout->addWidget(inclValue,1,1,1,1);
	surfaceLayout->addWidget(inclValue2,1,2,1,1);
	surfaceLayout->addWidget(albedoLabel,2,0);
	surfaceLayout->addWidget(albedoValue,2,1);
	surfaceLayout->addWidget(areaLabel,3,0,1,1);
	surfaceLayout->addWidget(areaValue,3,1,1,1);
	surfaceLayout->addWidget(areaValue2,3,2,1,1);
	surfaceLayout->addWidget(numOfPanels,4,0,1,1);
	surfaceLayout->addWidget(numOfPanelsValue,4,1,1,1);
	surfaceLayout->addWidget(numOfPanelsValue2,4,2,1,1);
  	surfaceLayout->addWidget(canvas,5,0,3,3);
	surfaceLayout->addWidget(limitDistanceLabel,8,0,1,1);
	surfaceLayout->addWidget(limitDistanceValue,8,1,1,2);
	surfaceLayout->addWidget(trackDim,9,0,1,1);
	surfaceLayout->addWidget(trackDimValue,9,1,1,2);
	surfaceLayout->addWidget(mountingLabel,10,0,1,1);
	surfaceLayout->addWidget(mountingValue,10,1,1,2);
	surfaceLayout->addWidget(mountingHeightLabel,11,0,1,1);
	surfaceLayout->addWidget(mountingHeightValue,11,1,1,2);
	surfaceLayout->addWidget(concRatioLabel,12,0,1,1);
	surfaceLayout->addWidget(concRatioValue,12,1,1,2);
//    	surfaceLayout->addWidget(bF,12,0);
//  bF->show();
	surfaceLayout->setRowStretch(13,10);
 
	QWidget *surface      = new QWidget;
 
	surface->setLayout(surfaceLayout);
		
	


//	QGridLayout *radLayout = new QGridLayout;

	optiIncl = new QLabel;
	optiInclValue = new QLabel;
	maxIrrHb = new QLabel ;
	maxIrrHb->setWordWrap(true);
	maxIrrHbValue = new QLabel ;
	maxIrrHb->setText(tr("Hb extraatmosferica"));
	maxIrrHb->setToolTip(tr("<p>Radiazione diretta all'esterno dell'atmosfera</p>"));
	maxIrrHb->setWordWrap(true);
	
	maxIrrHincl = new QLabel ;
	maxIrrHinclValue = new QLabel ;//wattLabel2
	
	maxIrrHinclValue->setTextInteractionFlags(Qt::TextSelectableByMouse);
	maxIrrHinclValue->setAutoFillBackground(true);
        maxIrrHincl->setText(tr("H annua"));
	maxIrrHincl->setToolTip(tr("<p>Radiazione incidente annua</p>"));
	QString c = "darkkhaki";
	changeColor(*maxIrrHinclValue,c);
	
	maxIrrHinclOmbre      = new QLabel ;
	maxIrrHinclOmbreValue = new QLabel  ;//wattLabel2
	maxIrrHinclOmbreValue->setTextInteractionFlags(Qt::TextSelectableByMouse);
	maxIrrHinclOmbreValue->setAutoFillBackground(true);
        maxIrrHinclOmbre->setText(tr("H annua con ombre"));
	maxIrrHinclOmbre->setToolTip(tr("<p>Radiazione incidente annua con ombre</p>"));
	maxIrrHinclOmbre->setWordWrap(true);
	 
	changeColor(*maxIrrHinclOmbreValue,c);
	

	meanIrrHincl	      = new QLabel;
	
	meanIrrHincl->setText(tr("H media giornaliera"));
	meanIrrHincl->setToolTip(tr("<p>Radiazione incidente media in un giorno</p>"));
	meanIrrHincl->setWordWrap(true);
	meanIrrHinclValue     = new QLabel;
	meanIrrHinclValue->setTextInteractionFlags(Qt::TextSelectableByMouse);//wattLabel3
	
	changeColor(*maxIrrHinclOmbreValue,c);
// 	maxIrrHinclOmbre->setText(tr("Radiazione incidente annua con ombre"));
 
		
	
	unit<<"MJ/m2"<<"kWh/m2";
	unitE<<"MJ"<<"kWh";
//         wattLabel = new QPushButton(tr("MJ/m2"));
// 	wattLabel->setToolTip(tr("<p> Clicca per cambiare unit&agrave;<p>"));
 	wattLabel2 = new QPushButton(tr("MJ/m2"));
 	wattLabel2->setToolTip(tr("<p> Clicca per cambiare unit&agrave;<p>"));
//         wattLabel3 = new QPushButton(tr("MJ/m2/giorno"));
// 	wattLabel3->setToolTip(tr("<p> Clicca per cambiare unit&agrave;<p>"));
// 	wattOptiLabel = new QPushButton(tr("MJ/m2"));
//         wattLabel3->setFlat(true);
 	wattLabel2->setFlat(true);
// 	wattLabel->setFlat(true);
// 	wattOptiLabel->setFlat(true);
	
	
	/*
	wattLabel3->setStyleSheet(QString::fromUtf8("QPushButton:flat {"
     		"border: none; /* no border for a flat push button "
//  		"}"));*/
// 	wattLabel2->setStyleSheet(QString::fromUtf8("QPushButton:flat {"
//      		"border: none; /* no border for a flat push button "
//   		"}"));
// 	wattLabel->setStyleSheet(QString::fromUtf8("QPushButton:flat {"
//      		"border: none; /* no border for a flat push button */"
//  		"}"));
// 	wattOptiLabel->setStyleSheet(QString::fromUtf8("QPushButton:flat {"
//      		"border: none; /* no border for a flat push button */"
//  		"}"));

	
	inclOptiLabel = new QLabel;
	inclOptiLabel->setText(tr("Senza Ombre"));
	inclOptiOmbreLabel = new QLabel;
	inclOptiOmbreLabel->setText(tr("Con Ombre"));

	inclOptiValue = new QLabel ;
	inclOptiValue->setFrameStyle(QFrame::Plain|QFrame::Box);
	inclOptiValue->setTextInteractionFlags(Qt::TextSelectableByMouse);
	inclOptiValue->setText("      ");
        inclOptiCheck = new QCheckBox(tr("Calcolo tilt ottimo") );
	
	inclOptiValueOmbre = new QLabel;
	inclOptiValueOmbre->setFrameStyle(QFrame::Plain|QFrame::Box);
	inclOptiValueOmbre->setFrameStyle(QFrame::Plain|QFrame::Box);
	inclOptiValueOmbre->setText("      ");

        okButton = new QPushButton(tr("Tilt ottimo"));
	okButton->setEnabled(false);


	
//	radLayout->addWidget(maxIrrHb,0,0);
//	radLayout->addWidget(maxIrrHbValue,0,1);
//	radLayout->addWidget(wattOptiLabel,0,2);
//	radLayout->addWidget(maxIrrHincl,1,0);
//	radLayout->addWidget(maxIrrHinclValue,1,1);
//
//        radLayout->addWidget(wattLabel,1,2);
//	radLayout->addWidget(meanIrrHincl,2,0);
//	radLayout->addWidget(meanIrrHinclValue,2,1);
//	radLayout->addWidget(wattLabel3,2,2);
//	radLayout->addWidget(maxIrrHinclOmbre,3,0);
//	radLayout->addWidget(maxIrrHinclOmbreValue,3,1);
//        radLayout->addWidget(wattLabel2,3,2);
        //radLayout->addWidget(wattCombo,3,0);
//        radLayout->addWidget(inclOptiCheck,4,0);
//	radLayout->addWidget(inclOptiLabel,5,0);
//	radLayout->addWidget(inclOptiValue,5,1);
//	radLayout->addWidget(inclOptiOmbreLabel,6,0);
//	radLayout->addWidget(inclOptiValueOmbre,6,1);
//         radLayout->addWidget(inclOptiValue,4,1);
//        radLayout->addWidget(okButton,7,1);
//        radLayout->setRowStretch(4,10);
//	QWidget *radiation = new QWidget;
//	radiation->setLayout(radLayout);
	
// 	connect(okButton,SIGNAL(clicked()),this,SLOT(getOptiIncl()));
//         connect(inclOptiCheck,SIGNAL(stateChanged(int)),SLOT(stateChanged(int)));
	QVector<int> d;
	d<<0;

	QWidget *meteo = new QWidget;
	windLabel    = new QLabel(tr("Vel. vento(m/s) "));
	windLabel->setWordWrap(true);
	windValue    = new QDoubleSpinBox;
	windValue->setMinimum(0);
	windValue->setMaximum(500);
	windValue->setValue(localita.wind);

	windDailyTable = new QTableWidget(0,1,meteo);
	windDailyTable->setItemDelegate(new DoubleDelegate(d,200,0,2));
	windDailyTable->horizontalHeader()->setStretchLastSection(true);
        windDailyTable->setHorizontalHeaderLabels(QStringList()<<tr("Vel. vento media giornaliera(m/s)"));

	windLoadButton = new QPushButton(tr("Carica"));
	windLoadButton->setToolTip(tr("Carica valori medi mensili da file di testo"));
        windClearButton = new QPushButton(tr("Azzera"));
	windClearButton->setToolTip(tr("Imposta a 0 i valori medi mensili"));
        windResetButton = new QPushButton(tr("Reset"));
	windResetButton->setToolTip(tr("Ricarica i valori medi mensili dal database, se presente"));
        windUpdatePower = new QPushButton(tr("Applica"));
	windUpdatePower->setToolTip(tr("Applica i valori editati al sistema corrente"));

	tempMinLabel = new QLabel(tr("Temp. minima annuale(gradi)"));
	tempMinLabel->setWordWrap(true);
	tempMaxLabel = new QLabel(tr("Temp. max annnuale(gradi)"));
	
	tempMaxLabel->setWordWrap(true);
	tempMinValue = new QDoubleSpinBox;
	tempMinValue->setMinimum(-100);
	tempMinValue->setMaximum(100);
	tempMaxValue = new QDoubleSpinBox;
	tempMaxValue->setMinimum(-100);
	tempMaxValue->setMaximum(100);
	#ifndef PLUSVERSION
	tempMinLabel->setVisible(false);
	tempMinValue->setVisible(false);
	tempMaxLabel->setVisible(false);
	tempMaxValue->setVisible(false);
	#endif

#ifdef PLUSVERSION
	connect(tempMinValue,SIGNAL(valueChanged(double)),inverterCheck,SLOT(minTempChanged(double)));
	connect(tempMaxValue,SIGNAL(valueChanged(double)),inverterCheck,SLOT(maxTempChanged(double)));
#endif
	tempExplainLabel = new QLabel(tr("Premi Reset per ricaricare i dati dal database"));
	tempDailyTable = new QTableWidget(0,1,meteo);
	
	tempDailyTable->setItemDelegate(new DoubleDelegate(d,70,-50,2));
	

	tempDailyTable->horizontalHeader()->setStretchLastSection(true);
	tempDailyTable->setHorizontalHeaderLabels(QStringList()<<tr("Temp. media giornaliera(gradi)"));
	
        tempLoadButton = new QPushButton(tr("Carica"));
	tempLoadButton->setToolTip(tr("Carica valori medi mensili da file di testo"));
        tempClearButton = new QPushButton(tr("Azzera"));
	tempClearButton->setToolTip(tr("Imposta a 0 i valori medi mensili"));
        tempResetButton = new QPushButton(tr("Reset"));
	tempResetButton->setToolTip(tr("Ricarica i valori medi mensili dal database, se presente"));
        tempUpdatePower = new QPushButton(tr("Applica"));
	tempUpdatePower->setToolTip(tr("Applica i valori editati al sistema corrente"));
	
	resetTempDaily(1);
	resetWindDaily(1);

	tempNote  = new QLabel(tr("NOTA"));
	tempNote->setWordWrap(true);
	tempNote->setText(tr("NOTA: Perdite termiche negative vengono assunte pari a zero."));

        connect(windDailyTable,SIGNAL(itemChanged( QTableWidgetItem *  )),SLOT(windChangedPower()));
        connect(windLoadButton,SIGNAL(clicked()),SLOT(loadWindFile()));
	//connect(tempMinValue,SIGNAL(editingFinished()),SLOT(updatePower()));
	//connect(tempMaxValue,SIGNAL(editingFinished()),SLOT(updatePower()));
	connect(windClearButton,SIGNAL(clicked()),SLOT(clearWind()));	
	connect(windResetButton,SIGNAL(clicked()),SLOT(reloadWind()));	
        connect(windUpdatePower,SIGNAL(clicked()),SLOT(updateWindDaily()));


// 	connect(windValue,SIGNAL(editingFinished()),SLOT(updatePower()));

        connect(tempDailyTable,SIGNAL(itemChanged( QTableWidgetItem *  )),SLOT(tempChangedPower()));
        connect(tempLoadButton,SIGNAL(clicked()),SLOT(loadTempFile()));
	//connect(tempMinValue,SIGNAL(editingFinished()),SLOT(updatePower()));
	//connect(tempMaxValue,SIGNAL(editingFinished()),SLOT(updatePower()));
	connect(tempClearButton,SIGNAL(clicked()),SLOT(clearTemp()));	
	connect(tempResetButton,SIGNAL(clicked()),SLOT(reloadTemp()));	
        connect(tempUpdatePower,SIGNAL(clicked()),SLOT(updateTempDaily()));

	QFrame *line = new QFrame(this);
	QFrame *line2 = new QFrame(this);
        line->setObjectName(QString::fromUtf8("line"));

        line->setFrameShape(QFrame::HLine);
        line->setFrameShadow(QFrame::Sunken);

	line2->setObjectName(QString::fromUtf8("line"));
        line2->setFrameShape(QFrame::HLine);
        line2->setFrameShadow(QFrame::Sunken);



	QGridLayout *meteoLayout = new QGridLayout;
// 	meteoLayout->addWidget(windLabel,0,0);
// 	meteoLayout->addWidget(windValue,0,1);
	meteoLayout->addWidget(windDailyTable,0,0,1,2);
 
	meteoLayout->addWidget(windLoadButton,1,0);
	meteoLayout->addWidget(windClearButton,1,1);
	meteoLayout->addWidget(windResetButton,2,0);
        meteoLayout->addWidget(windUpdatePower,2,1);
	meteoLayout->addWidget(line,3,0,1,2);
	meteoLayout->addWidget(tempMinLabel,4,0);
	meteoLayout->addWidget(tempMinValue,4,1);
	meteoLayout->addWidget(tempMaxLabel,5,0);
	meteoLayout->addWidget(tempMaxValue,5,1);
	meteoLayout->addWidget(line2,6,0,1,2);
        meteoLayout->addWidget(tempDailyTable,7,0,1,2);
	meteoLayout->addWidget(tempLoadButton,8,0);
	meteoLayout->addWidget(tempClearButton,8,1);
	meteoLayout->addWidget(tempResetButton,9,0);
        meteoLayout->addWidget(tempUpdatePower,9,1);
  	meteoLayout->addWidget(tempExplainLabel,10,0,1,2);
 	 meteoLayout->addWidget(tempNote,11,0);
//         meteoLayout->setColumnStretch(4,10);
	meteoLayout->setRowStretch(11,10);
	meteo->setLayout(meteoLayout);


// 	monthToolButton = new QToolButton

	
	
	toolBox = new QToolBox;
	toolBox->setStyleSheet("QToolBox::tab {"
   	 "background: qlineargradient(spread:reflect, x1:1, y1:0.647273, x2:1, y2:0.028, stop:0 rgba(255, 213, 128, 255), stop:1 rgba(255, 255, 255, 255)) ; "
     "border-radius: 2px;"
     "color: black;"
      "}"
	"QToolBox::tab:selected { /* italicize selected tabs */"
     "font: italic;"
     "color: black;"
 	"}");
 	toolBox->setItemIcon(0,QIcon(":/images/save.png"));
        toolBox->setFrameShape(QFrame::Box);
   	toolBox->setSizePolicy(QSizePolicy(QSizePolicy::Maximum, QSizePolicy::Expanding));
 	toolBox->setMinimumWidth(mainSettings->sizeHint().width()+10);
	toolBox->addItem(mainSettings,QIcon(":/images/site.png"),tr("Sito"));
	toolBox->addItem(surface,QIcon(":/images/supcap.png"),tr("Superficie captante"));
	
	toolBox->addItem(meteo,QIcon(":/images/meteo.png"),tr("Dati Meteo"));
//	toolBox->addItem(radiation,tr("Risultati radiazione"));
// 	connect(toolBox,SIGNAL(currentChanged(int)),SLOT(showSuggestion(int)));

//	QWidget *delWidget = new QWidget;
//	dockMyPlot = new QDockWidget(tr("Diagramma solare"), delWidget);
//  	dockMyPlot->setAllowedAreas( Qt::RightDockWidgetArea);
//        dockMyPlot->setMinimumWidth(delWidget->width()/2);
	mainH->addWidget(toolBox,0,0);
        mainH->addWidget(tabWidget,0,1);
	QWidget *central=new QWidget;
	central->setLayout(mainH);
	setCentralWidget(central);
	
	locValue->setFocus( );
}

// void MainWindow::showSuggestion(int i)
// {
// //   if (i==captureSurface)
// // {
// // 	
// // 	
// //       		bF->start();
// // 	qDebug()<<"SHOWSUGGESTION";
// // }
// }
void MainWindow::ombreChanged()
{
	qDebug()<<"Ombre changed in mainwindow...";
// 	reale->setOmbre(w->getShadowFactor());
 	createOptimumPlot();
 	setIntegrationInterval();
	w->computeShadow();
	
 	createRealePlot();
	updatePower();
	ombrePresent = w->ombrePresent();
//	set();
}

void MainWindow::printPreamble(QTextStream &out)
{
/*TODO*/	
	QString sistema;
	if (localita.tipo == 1)
		sistema = tr("Inseguitore biassiale");
	if (localita.tipo == 0)
		sistema = tr("Tilt fisso");
	if (localita.tipo == 2)
		sistema = tr("Doppia falda");

	   out <<'\n'<<tr("Loc.: ")<<'\t'<<localita.name<<'\n'
	   <<tr("Tilt: ")<<'\t'<<localita.incl<<'\n'
	   <<tr("Tipo: ")<<'\t'<<sistema<<'\n'
	   <<tr("Azimuth: ")<<'\t'<<localita.azi<<'\n'
	   <<tr("Latitudine: ")<<'\t'<<localita.lat<<'\n'
		<<tr("Gradi-Min-Sec")<<QString::number(localita.latGradi)<<QString::number(localita.latMin)<<QString::number(localita.latSec)<<'\n'
	   <<tr("Longitudine:")<<'\t'<<localita.lon<<'\n'
		<<tr("Gradi-Min-Sec")<<QString::number(localita.lonGradi)<<QString::number(localita.lonMin)<<QString::number(localita.lonSec)<<'\n';
	 out<<tr("PANNELLO FOTOVOLTAICO-------------------")<<'\n';
	  if (thisProjectPanel.isValid)
	   
	   out<<tr("Marca:")<<'\t'<<thisProjectPanel.fabric<<'\n'
	   <<tr("Tipo:")<<'\t'<<thisProjectPanel.model <<'\n'
	   <<tr("Pnom:")<<'\t'<<thisProjectPanel.pnom<<'\n'
	   <<tr("Efficienza:")<<'\t'<<thisProjectPanel.eff<<'\n';
	   else
	   out<<tr("Marca:")<<'\n'
	   <<tr("Tipo:")<<'\n'
	   <<tr("Pnom:")<<'\n'
	   <<tr("Efficienza:")<<'\n';
	out<<tr("INVERTER (For complex system see the minireport)-------------------")<<'\n';
	if (thisProjectInverter.isValid)
	   out<<tr("Marca:")<<'\t'<<thisProjectInverter.fabric<<'\n'
	   <<tr("Tipo:")<<'\t'<<thisProjectInverter.model <<'\n'
	   <<tr("Pnom:")<<'\t'<<thisProjectInverter.pnom<<'\n'
	   <<tr("Efficienza:")<<'\t'<<thisProjectInverter.eff<<'\n';
	   else
	   out<<tr("Marca:")<<'\n'
	   <<tr("Tipo:")<<'\n'
	   <<tr("Pnom:")<<'\n'
	   <<tr("Efficienza:")<<'\n'<<'\n';
	out<<tr("Media Altre perdite:")<<'\t'<<QString::number(MyMath::mean(otherLosses.otherLoss))<<'\n';

           out<<tr("Radiazione in:")<<'\t'<<unit.at(reale->getUnit()-1)<<'\n'
	   <<tr("Energia annuale:")<<'\t'<<totEnergy<<unit.at(energyOutUnit-1)<<'\n'
	   <<"-------------------------------------------\n";
	   
}
void MainWindow::setIntegrationInterval()
{
	/* Fisso gli estremi di integrazione */
	/* per il calcolo delle ombre        */
	/* L'intervallo si puo' calcolare o in base a UNI 8477*/
	/* oppure in base agli angoli orari del sorgere e tramontare del sole*/
	/* Questi angoli sono disponibili in MyPlot */

	if (o!=0 && w!=0) {
		if (integrationType == custom_) {
		/* Se l'integrazione non e' fra gli estremi dettati */
		/* dalla norma UNI, usiamo il metodo di default di MyPlot */
// 		MyMath::convertToDegree(omegaApp,12);
// 		MyMath::convertToDegree(omegaSco,12);
		MyMath::convertToDegree(omegaApp);
 		MyMath::convertToDegree(omegaSco);
		w->setOmegaApp(omegaApp);
		w->setOmegaSco(omegaSco);
		
                //qDebug()<<"Integration type set to"<<integrationType;
		}
	}
}
void MainWindow::createSettings()
{
	switch (localita.radCorrModel) {
		case 1:
		modelSettings->radioUNI->setChecked(true);
		break;
		case 2:
		modelSettings->radioEnea->setChecked(true);
		break;
		case 3:
		modelSettings->radioErbs->setChecked(true);
		break;
	}

	switch (otherLosses.thermalModel) {
		case NOCT:
		modelSettings->radioNOCT1->setChecked(true);
		break;
		case CEA:
		modelSettings->radioCEA->setChecked(true);
		break;
		case other:
		modelSettings->radioOther->setChecked(true);
		 
	}
	if (localita.ombreModel==0)
  		modelSettings->radioOmbreLineari->setChecked(true);
	
	
	if (localita.ombreModel==1)
  	modelSettings->radioOmbreSpline->setChecked(true);

	if (localita.tipo==0){
// 		modelSettings->radioTilt->setChecked(true);
		modelSettings->comboType->setCurrentIndex(0);
		inclValue->setEnabled(true);
		aziValue->setEnabled(true);
			inclValue2->setVisible(false);
			aziValue2->setVisible(false);
			areaValue2->setVisible(false);
			numOfPanelsValue2->setVisible(false);
			if (comboCurrentField->count()>1)
				comboCurrentField->removeItem(1);
	}
	if (localita.tipo==1){
// 		modelSettings->radioBiAx->setChecked(true);
		modelSettings->comboType->setCurrentIndex(1);
		inclValue->setEnabled(false);
		aziValue->setEnabled(false);
			inclValue2->setVisible(false);
			aziValue2->setVisible(false);
			areaValue2->setVisible(false);
			numOfPanelsValue2->setVisible(false);
			if (comboCurrentField->count()>1)
				comboCurrentField->removeItem(1);
	}
	if (localita.tipo==2){
		
		modelSettings->comboType->setCurrentIndex(2);
		inclValue->setEnabled(true);
		aziValue->setEnabled(true);
		inclValue2->setEnabled(true);
			aziValue2->setVisible(true);
			areaValue2->setVisible(true);
			inclValue2->setVisible(true);
			numOfPanelsValue2->setVisible(true);
			comboCurrentField->addItem("2");
		//
	}
	
if (canvas){
				canvas->setType(localita.mounting);
				canvas->setTiltType(localita.tipo);
				if (localita.tipo==2){
				canvas->setTilt(QVector<double>()<<inclValue->value()<<inclValue2->value());
				canvas->setAzimuth(QVector<double>()<<aziValue->value()<<aziValue2->value());
				canvas->update();
				}
				else
				{
					canvas->setTilt(QVector<double>()<<inclValue->value());
					canvas->setAzimuth(QVector<double>()<<aziValue->value());
					canvas->update();
				}
}

// qDebug()<<"MW CREATE SETTIGNS"<<localita.tipo;
}
void MainWindow::updateModelSettings()
{
	int corr,ombre,tm,type,sim;
	sim = 0;
        corr = 1;
	if (modelSettings->exec()) {

		
		

		if (modelSettings->radioUNI->isChecked())
			corr = 1;
		if (modelSettings->radioEnea->isChecked())
			corr = 2;
		if (modelSettings->radioErbs->isChecked())
			corr = 3;
		
		if (localita.radCorrModel!=corr){
			localita.radCorrModel=corr;
			sim++;
		}

		if (modelSettings->radioOmbreLineari->isChecked())
			ombre = 0;
		if (modelSettings->radioOmbreSpline->isChecked())
			ombre  = 1;

		if (ombre!=localita.ombreModel){
			localita.ombreModel = ombre;
			sim++;
		}
		
		if (modelSettings->radioCEA->isChecked())
			tm = CEA;
		if (modelSettings->radioNOCT1->isChecked())
			tm = NOCT;
		if (modelSettings->radioOther->isChecked())
			tm = other;

		if (otherLosses.thermalModel!=tm){
			otherLosses.thermalModel = tm;
			sim++;
		}
		

		if (modelSettings->comboType->currentIndex()==0)  {
			type = 0;
			inclValue->setEnabled(true);
			aziValue->setEnabled(true);
			aziValue2->setVisible(false);
			areaValue2->setVisible(false);
			inclValue2->setVisible(false);
			numOfPanelsValue2->setVisible(false);
			
			mountingValue->clear();
			mountingValue->addItems(QStringList()<<tr("Su guida")<<tr("BIPV")<<tr("Schiera"));
			localita.additionalIncl.resize(0);
			localita.additionalAzi.resize(0);
			localita.additionalArea.resize(0);
			if (comboCurrentField->count()>1)
				comboCurrentField->removeItem(1);
			
		}

		if (modelSettings->comboType->currentIndex()==1){
			type= 1;
			
			mountingHeightValue->setEnabled(true);
			inclValue->setEnabled(false);
			aziValue->setEnabled(false);
			inclValue2->setVisible(false);
			aziValue2->setVisible(false);
			areaValue2->setVisible(false);
			numOfPanelsValue2->setVisible(false);
			
			
			localita.additionalIncl.resize(0);
			localita.additionalAzi.resize(0);
			localita.additionalArea.resize(0);
			if (comboCurrentField->count()>1)
				comboCurrentField->removeItem(1);
		}
		
		if (modelSettings->comboType->currentIndex()==2){
			type= 2;
			
			mountingHeightValue->setEnabled(true);
			inclValue->setEnabled(true);
			aziValue->setEnabled(true);

			inclValue2->setVisible(true);
			aziValue2->setVisible(true);
			areaValue2->setVisible(true);
			numOfPanelsValue2->setVisible(true);
			
			mountingValue->clear();
			mountingValue->addItems(QStringList()<<tr("Su guida")<<tr("BIPV"));
			localita.additionalArea<<areaValue2->value();
			localita.additionalAzi<<aziValue2->value();
			localita.additionalIncl<<inclValue2->value();
			comboCurrentField->addItem("2");
			
			
		}

		if (type!=localita.tipo){
			localita.tipo = type;
			sim++;
		}

		 w->setShadowCombineMode(localita.ombreModel);

		reale->setModel(localita.radCorrModel);

		if (localita.tipo==1)
		{
			if ((mountingValue) && (trackDimValue)){
  			mountingValue->setEnabled(false);
			mountingHeightValue->setEnabled(true);
			trackDimValue->setValue(sqrt(areaValue->value()));
// 			qDebug()<<"MW mounting value enabled";
			}
		}
		else
			{	
// 			qDebug()<<"MW mounting value enabled";
			mountingValue->setEnabled(true);
			mountingHeightValue->setEnabled(false);
		 }
		
		
	}
	
	if (canvas)
	{
				canvas->setType(localita.mounting);
				
				if (localita.tipo==2){
				canvas->setTilt(QVector<double>()<<inclValue->value()<<inclValue2->value());
				canvas->setAzimuth(QVector<double>()<<aziValue->value()<<aziValue2->value());
				
				}
				else
				{
					canvas->setTilt(QVector<double>()<<inclValue->value());
					canvas->setAzimuth(QVector<double>()<<aziValue->value());
				
				}
					updateLimitDistance();
				canvas->setTiltType(localita.tipo);
	}

if (sim>0)
			set();
		
	 
// 	qDebug()<<"Modello ombre...."<<localita.ombreModel;
// 	qDebug()<<"Model correlazione..."<<localita.radCorrModel;
// 
}

void MainWindow::setupGuiPanels()
{	
	/* This function must be called if a database is open*/
	datiPanels   = new DatiPannello(this);
	datiInverter = new DatiInverter(this);
	QSqlDatabase db = QSqlDatabase::database(databasePanelsId);
	datiPanels->setDatabase(db,"pannelli");
	datiInverter->setDatabase(db,"inverter");
}

void MainWindow::updatePower()
{
// 	localita.area = areaValue->value();
	
//   	otherLosses.otherLoss = otherLoss->value();
        updateSitePar();
// 	qDebug()<<"MW updatePower()"<<localita.mountingHeight;
	if (somethingChanged())
	{
// 		updateSitePar();
		set();
	}
	else
		if ((!wrongCoordinates) || !noNameAvailable || googleNameAvailable || estimatedCoordinates)
                        if (thisProjectPanel.isValid)
                    {
				
                               // qDebug()<<"MainWindow aggiorno  EnergyOut...temp"<<tempDaily;
                                //qDebug()<<"MainWindow aggiorno  EnergyOut...wind"<<windDaily;
  				createRealePlot();
                                createEnergyOutPlot();
				drawHourlyValues();
				createCheckInverter();
                    }
}
//
//void MainWindow::updateRealeUnit()
//{
//    wattCombo->setCurrentIndex(reale->getUnit()-1);
//
//
//}
void MainWindow::updateEnergyUnit()
{
	if (energyOut) {
		energyOutUnit = energyOut->getUnit();
		effTemp   = energyOut->getEffTemp();
		Energy    = energyOut->getRealEnergy();
		totEnergy = energyOut->getTotEnergy();
	}
}
void MainWindow::resetWindDaily(int mode)
{
	/* mode =1, create new rows, mode=0, reset only value */
	QStringList s;
	
	if (windDailyTable) {
                windDaily.resize(0);
		for(int i=0;i<12;i++) {
			if (mode==1)
                        {   /* We do not have a table item at all, create it*/
				windDailyTable->insertRow(i);
				QTableWidgetItem *item = new QTableWidgetItem;
				item->setText(QString::number(0));
				item->setTextAlignment(Qt::AlignRight | Qt::AlignVCenter);
				windDailyTable->setItem(i,0,item);
                                
			}
			if ( (mode==0) && (tempDailyTable->item(i,0)) ) {
				windDailyTable->item(i,0)->setText(QString::number(0));

				/*reset also the vecotr */
				
			}
			windDaily<<0;
			otherLosses.wind<<0;
		}
	if (mode == 1)
	windDailyTable->setVerticalHeaderLabels(MyMath::monthFull());
	}
	if (mode == 0){
	/* We cleared all the values, we must rerun updatePoswer() */
	updatePower();
	}
	
}
void MainWindow::resetTempDaily(int mode )
{
	/* mode =1, create new rows, mode=0, reset only value */
	QStringList s;
	
	if (tempDailyTable) {
                tempDaily.resize(0);
		for(int i=0;i<12;i++) {
			if (mode==1)
                        {   /* We do not have a table item at all, create it*/
				tempDailyTable->insertRow(i);
				QTableWidgetItem *item = new QTableWidgetItem;
				item->setText(QString::number(0));
				item->setTextAlignment(Qt::AlignRight | Qt::AlignVCenter);
				tempDailyTable->setItem(i,0,item);
                                
			}
			if ( (mode==0) && (tempDailyTable->item(i,0)) ) {
				tempDailyTable->item(i,0)->setText(QString::number(0));

				/*reset also the vecotr */
				
			}
			tempDaily<<0;
			otherLosses.temperatures<<0;
		}
	if (mode == 1)
	tempDailyTable->setVerticalHeaderLabels(QStringList()<<tr("Gennaio")<<tr("Febbraio")<<tr("Marzo")<<tr("Aprile")<<tr("Maggio")<<tr("Giugno")<<tr("Luglio")<<tr("Agosto")<<tr("Settembre")<<tr("Ottobre")<<tr("Novembre")<<tr("Dicembre"));
	}
	if (mode == 0){
	/* We cleared all the values, we must rerun updatePoswer() */
	updatePower();
	}
	
}
void MainWindow::updateWindDaily()
{
        double t;
//	/* We could use a model here, but the result is not much different */
//         qDebug()<<"MW updateWindDaily inizio..........";
         if (windDailyTable) {
             windDaily.resize(0);
  	     otherLosses.wind.resize(0);
             for(int i=0;i<12;i++) {

                                t=windDailyTable->item(i,0)->text().toDouble();
                                windDaily<<t;
  				otherLosses.wind << t;
#ifdef DEBUG
                                qDebug()<<"MW updateTempDaily"<<i<<t<<windDailyTable->item(i,0)->text();
#endif
                        }
                }
	
	
         qDebug()<<"MW windDaily updated..."<<otherLosses.wind;
        windUpdatePower->setEnabled(false);
        updatePower();
	windDataIsEdited = true;
		
}
void MainWindow::updateTempDaily()
{
        double t;
//	/* We could use a model here, but the result is not much different */
//         qDebug()<<"MW updateTempDaily inizio..........";
         if (tempDailyTable) {
             tempDaily.resize(0);
  	     otherLosses.temperatures.resize(0);
             for(int i=0;i<12;i++) {

                                t=tempDailyTable->item(i,0)->text().toDouble();
                                tempDaily<< t;
  				otherLosses.temperatures << t;
#ifdef DEBUG
                               qDebug()<<"MW updateTempDaily"<<i<<t<<tempDailyTable->item(i,0)->text();
#endif
                        }
                }
	
	
//         qDebug()<<"MW tempDaily updated..."<<otherLosses.temperatures;
        tempUpdatePower->setEnabled(false);
        updatePower();
	tempDataIsEdited = true;
		
}
void MainWindow::updateWindWidget()
{
  if (windDailyTable) {
	for (int i=0;i<12;i++) {
		if (i<windDaily.size()) {
			windDailyTable->item(i,0)->setText(QString::number(windDaily.at(i),'f',2));
			
		}
	}

  }
  
}
void MainWindow::updateTempWidget()
{
  if (tempDailyTable) {
	for (int i=0;i<12;i++) {
		if (i<tempDaily.size()) {
			tempDailyTable->item(i,0)->setText(QString::number(tempDaily.at(i),'f',2));
			
		}
	}

  }
// qDebug()<<"MainWinodw updateWidget"<< tempDaily;
}
void MainWindow::clearTemp()
{
	resetTempDaily(0);
	
}
void MainWindow::clearWind()
{
	resetWindDaily(0);
	
}
void MainWindow::reloadWind()
{
// 	switch (localita.source) {
// 		case radEnea:
// 			loadWind(false);
// 		break;
// 		case radNasa:
                        windDaily.resize(0);
			
                        findNasaData(localita.lat,localita.lon,localita.latGradi,localita.latMin,localita.latSec,
                                                 localita.lonGradi,localita.lonMin,localita.lonSec,2);
// 			windDaily = n.data;
			otherLosses.wind = windDaily;
			adjustVector(windDaily);
			updateWindWidget( );
			updatePower();
// 		break;
// 		case radPvgis:
// 		break;
// 		case radCustom:
// 			loadWind(false);
// 		break;
// 	}
	windDataIsEdited = false;
}

void MainWindow::reloadTemp()
{
// 	switch (localita.source) {
// 		case radEnea:
// 			loadTemp(false);
// 		break;
// 		case radNasa:
                        tempDaily.resize(0);
			
                        findNasaData(localita.lat,localita.lon,localita.latGradi,localita.latMin,localita.latSec,
                                                 localita.lonGradi,localita.lonMin,localita.lonSec,1);
// 			tempDaily = t.data;
			otherLosses.temperatures = tempDaily;
			adjustVector(tempDaily);
			updateTempWidget( );
// 			updatePower();
// 		break;
// 		case radPvgis:
// 		break;
// 		case radCustom:
// 			loadTemp(false);
// 		break;
// 	}
	tempDataIsEdited = false;
}
void MainWindow::loadWindFile()
{
	/* convenience function */	
	loadWind(true);
}
void MainWindow::loadTempFile()
{
	/* convenience function */	
	loadTemp(true);
}
void MainWindow::loadWind(bool newWind)

{
	 
	if (otherLosses.windPath.isEmpty() || newWind)
			otherLosses.tempPath = QFileDialog::getOpenFileName(this, tr("File venti"), recentDir, "Text files (*.txt  )");
	
	 QFileInfo fileInfo(otherLosses.windPath);
    	 
		
	
	QVector<double> temp;
	int condition;
	double x,y;
	condition = 0;
    	if ( !otherLosses.windPath.isEmpty() && fileInfo.exists())
    	{ 
                QFile file(otherLosses.windPath);
                
                recentDir = fileInfo.absoluteDir().absolutePath();
		QTextStream in(&file);
		if (file.open(QIODevice::ReadOnly)){
			while (!in.atEnd()) {
				QString lineRaw =in.readLine();
				lineRaw = lineRaw.simplified();
				QStringList l = lineRaw.split(" ");
//                                 qDebug()<<"MW load wind"<<l.size()<<lineRaw;
				if ( (l.size()<2) && (!lineRaw.isEmpty())) {
                                        QMessageBox::critical(this,tr("Importazione"),tr("Il file di dati deve avere almeno due colonne."),QMessageBox::Ok);

					return;
				}
				else 
				{
					if (!lineRaw.isEmpty()) {
						x = l.at(0).toDouble();
						y = l.at(1).toDouble();
                                                temp<<y;

					}
                                }
			}
				
					if ( temp.size()!=12 ) {
						int r2 = QMessageBox::question(this,tr("Errore"),tr("Il file contiene un numero di mesi diverso da 12. Se si continua, i mesi mancanti avranno valore nullo."),QMessageBox::Ok,QMessageBox::Cancel);
						if (r2==QMessageBox::Ok){
							  
							 resizeCustomWind(temp.size());
							 
						}
						else
							return;
					}
					else {
						windDaily.resize(0);
						windDaily = temp;
						
					}
				}
			 				
		}
	updateWindWidget();
	updatePower();
}
void MainWindow::loadTemp(bool newTemp)

{
	 
	if (otherLosses.tempPath.isEmpty() || newTemp)
			otherLosses.tempPath = QFileDialog::getOpenFileName(this, tr("File temperature"), recentDir, "Text files (*.txt  )");
	
	 QFileInfo fileInfo(otherLosses.tempPath);
    	 
		
	
	QVector<double> temp;
	int condition;
	double x,y;
	condition = 0;
    	if ( !otherLosses.tempPath.isEmpty() && fileInfo.exists())
    	{ 
                QFile file(otherLosses.tempPath);
                
                recentDir = fileInfo.absoluteDir().absolutePath();
		QTextStream in(&file);
		if (file.open(QIODevice::ReadOnly)){
			while (!in.atEnd()) {
				QString lineRaw =in.readLine();
				lineRaw = lineRaw.simplified();
				QStringList l = lineRaw.split(" ");
//                                 qDebug()<<"MW load temperature"<<l.size()<<lineRaw;
				if ( (l.size()<2) && (!lineRaw.isEmpty())) {
                                        QMessageBox::critical(this,tr("Importazione"),tr("Il file di dati deve avere almeno due colonne."),QMessageBox::Ok);

					return;
				}
				else 
				{
					if (!lineRaw.isEmpty()) {
						x = l.at(0).toDouble();
						y = l.at(1).toDouble();
                                                temp<<y;

					}
                                }
			}
				
					if (temp.size()!=12) {
						int r2 = QMessageBox::question(this,tr("Errore"),tr("Il file contiene un numero di mesi diverso da 12. Se si continua, i mesi mancanti avranno tempertura nulla."),QMessageBox::Ok,QMessageBox::Cancel);
						if (r2==QMessageBox::Ok) {
							  
							 resizeCustomTemp(temp.size());
							 
						}
						else
							return;
					}
					else {
						tempDaily.resize(0);
						tempDaily = temp;
						
					}
				}
			 				
		}
	updateTempWidget();
	updatePower();
}

void MainWindow::resizeCustomWind(int s)
{
	if (s>12)
			windDaily.resize(12);
			
		if (s<12) {
			for (int i=s;i<12-windDaily.size();i++)
				windDaily.append(0);
		}	
// 	qDebug()<<"MaiWindow Dati temperatura resize..."<<tempDaily;
}
void MainWindow::resizeCustomTemp(int s)
{
	if (s>12)
			tempDaily.resize(12);
			
		if (s<12) {
			for (int i=s;i<12-tempDaily.size();i++)
				tempDaily.append(0);
		}	
// 	qDebug()<<"MaiWindow Dati temperatura resize..."<<tempDaily;
}		

void MainWindow::saveAs()
{
	QString fileName;
	fileName = QFileDialog::getSaveFileName(this, tr("Salva progetto"),
                                recentSaveProject,
                                tr("SolarCalc (*.sc)"));
	if (!fileName.isEmpty())
	{
	saveProjectFile = fileName;
	save();
	}
	
}
void MainWindow::clearProject()
{
	
        if (pagesWidget)
            pagesWidget->setCurrentIndex(0);

	myplotpresent = false;
	 refCurveShown = false;
	 tempDataIsEdited = false;
	 windDataIsEdited = false;
	 doNotLoadTemp	  = false;
	 doNotLoadWind    = false;

	thisProjectPanel.isValid = false;
	thisProjectInverter.isValid = false;
	 
	resetStatusBar();


	 localita.radDirettaAnnuaTotale=0;
	 localita.additionalAzi.resize(0);
	 localita.additionalIncl.resize(0);
	 localita.additionalArea.resize(0);
	 localita.albedoType = con;
	 localita.wind = 0;
	 localita.mounting = rack;
	 localita.mountingHeight = 2.5;
	 localita.utc =0;
	 localita.anno=2009;
	 localita.lat = 0;
	 localita.latGradi =-999;
	 localita.latMin =-999;
	 localita.latSec =-999;
	 localita.lon = -999;
	 localita.lonGradi = -999;
	 localita.lonMin =-999;
	 localita.lonSec =-999;
	 
	 localita.alt = 0;
         localita.area = 0;
         localita.incl = 0;
         localita.azi = 0;
         localita.albedo = 0;
	 thisProjectPanel.isValid = false; /*no panel selected at the start*/
	 thisProjectInverter.isValid =false;
	 otherLosses.otherLoss.fill(0,12);
	 
	 otherLosses.tempPath ="";
	 otherLosses.ombrePath="";
	 otherLosses.nearOmbrePath="";
	 localita.tempMin = 0;
	 localita.tempMax = 40;
	 localita.ombreModel   = 0; /*sample and hold*/
	 localita.radCorrModel = 1; /* UNI */
	 localita.concRatio    = 1;
	 localita.tipo         = 0; /* Tilt fixed */
	 localita.source       = radEnea;
	 localita.radUnit      = megajoule;
	 
	 radNASAFile           = QCoreApplication::applicationDirPath() + "/nasa2005.txt";
	 tempNASAFile	       = QCoreApplication::applicationDirPath() + "/22yr_T10M";
	 estimatedCoordinates = false;
	 firstPassDone = false;
	 resetFlags();
	 saveProjectFile = "";
	 projectName = "(Untitled)";
	 projectIsDirty = false;
	/* Altri settaggi*/
	 validForExport = false;
	w->resetOmbre();
	w->drawMyContents(0);
	w->drawShadow(0,QPolygonF());
	o->drawContents(0);
	reale->resetOmbre();
	reale->drawContents(0,1);
	reale->drawRefCurve(0);
// 	reale->drawDailyValue(0);
	energyOut->drawContents(0);
	createSettings();
	resetWidgets();
	setNewCity(" ");	
	initializeModel();
	delete xmlBag;
	xmlBag = new XmlEngine;
	xmlBag->newTree();
		CS.resize(0);
		RawCash.resize(0);
		NPV.resize(0);
		Interest.resize(0);
		InterestNPV.resize(0);
	resetEnString();
	#ifdef PLUSVERSION
		if (inverterCheck)
			inverterCheck->resetAll();
	#endif
}
void MainWindow::resetWidgets()
{
		locValue->setText("");
		comuneValue->setText("");
		areaValue->setValue(0);
		inclValue->setValue(0);
		aziValue->setValue(0);
		otherLoss->setText(QString::number(0));	
		albedoValue->setValue(0);
		if (thisProjectPanel.isValid)
			numOfPanelsValue->setText(QString::number(0));
		else
			numOfPanelsValue->setText(QString(tr("<font color=\"red\"> pannello assente </font>")));
		windValue->setValue(0);
		inclOptiValue->setText("");
		gainValue->setText("");
		inclOptiValueOmbre->setText("");
		altitudeValue->setValue(0);
		
		
}
void MainWindow::newProject()
{
	if (projectIsDirty)
	{
	        if (ask()==QMessageBox::Yes)
		save();	
		 
	}
	else
	{
	 
	projectIsDirty = true;
	}
	clearProject();
	projectName = "(Untitled)";
#ifdef PLUSVERSION
	if (ecoVal)
		ecoVal->setProjectFolder(projectName);
#endif
	updateTitle(projectName);
}
int MainWindow::ask()
{
	
	int a =QMessageBox::question(this, tr("Progetto non salvato"),tr("Vuoi salvare le modifiche?"),QMessageBox::Yes|QMessageBox::No|QMessageBox::Cancel);
//         if (a ==QMessageBox::Yes)
//                 return true;
//         else
//                 return false;

	return a;
}
QPolygonF MainWindow::readShadow(const QString &g)
/* This function read back the 360 point shadow file */

{
	QPolygonF temp;
	QFile file(g);
        QFileInfo fileInfo(g);
        QFileInfo projectDir(projectName);

        if (!file.exists())
            /* The file does not exist: try to find it in the current project dir */
            file.setFileName(projectDir.absolutePath() + "/" +fileInfo.fileName());

	if (!file.open(QIODevice::ReadOnly)) {
                qDebug()<<"Cannot open shadow file"<<g<<file.fileName()<<qPrintable(file.errorString())<<endl;
		return QPolygonF();
	}
	QTextStream in(&file);
	
	while (!in.atEnd()) {
		QString line = in.readLine();
		QStringList fields = line.split(' ');
		if (fields.size()==2) 
			temp<<QPointF(fields.at(0).toDouble(),fields.at(1).toDouble());
		else{
			QMessageBox::warning(this,tr("Attenzione!"),tr("File di ombre danneggiato. Controlla"),QMessageBox::Ok);
			return QPolygonF();
		}
	}
	return temp;
}
void MainWindow::saveShadow(const QString &g,int mode)
{
	QFile file(g);	
	QPolygonF s;
	if (mode==horizon)
		s = w->getShadowCombined();
	if (mode==near)
                s = editor->getShadow();
	if(!file.open(QIODevice::WriteOnly)) {
	qDebug()<<"Cannot open file shadow for writing"<<g<<qPrintable(file.errorString());
	return;
	}
	if (s.size()>0){
			if (mode==horizon)
				otherLosses.ombrePath = g;
			if (mode==near)
				otherLosses.nearOmbrePath = g;
			QTextStream out(&file);
				for(int i=0;i < s.size();i++)
				{
                                        out<<s.at(i).x()<<" "<<s.at(i).y()<<"\n";
				}
	}
	
}
void MainWindow::save()
{
	QString shadowFile,shadowFileNear;
#ifdef DEBUG
qDebug()<<"Mainwindow salvo progetto"<<saveProjectFile;
#endif 
	QString fileName;
	if (saveProjectFile.isEmpty())
		   saveProjectFile  = QFileDialog::getSaveFileName(this, tr("Salva progetto"),recentSaveProject,tr("SolarCalc (*.sc)"));

	if (!saveProjectFile.isEmpty()){
		saveProjectFile = MyMath::checkFormat(saveProjectFile,"sc");
		
                QFileInfo fileInfo(saveProjectFile);
                recentSaveProject = fileInfo.absoluteDir().absolutePath();

		shadowFile     = saveProjectFile + ".shadow.txt" ;
		shadowFileNear = saveProjectFile + ".Nearshadow.txt" ;
		saveShadow(shadowFile,horizon);
		saveShadow(shadowFileNear,near);

		if (xmlBag){
  			delete xmlBag;
  			xmlBag = new XmlEngine();
  			xmlBag->newTree();

		updateSitePar();
		QFile f(saveProjectFile);
		xmlBag->setFile(&f);
		xmlBag->setLoc(localita);
		xmlBag->setPanelId(thisProjectPanel.isValid ? thisProjectPanel.indexDB:-1);
		xmlBag->setInverterId(thisProjectInverter.isValid ?thisProjectInverter.indexDB: -1);
		xmlBag->setOption(otherLosses);	

		ecopara tempEco;
		#ifdef PLUSVERSION
		if (ecoVal)
			tempEco = ecoVal->getEcoParameters();
		 

// 		if (loadInterface)
// 			tempEco.loadPath = loadInterface->getFileCustom();
			
		if (ecoVal)
			xmlBag->setEcoParameters(tempEco);

		if (inverterCheck)
			xmlBag->setSystem(inverterCheck->getInverters(),inverterCheck->getSystem());
		#endif
// 		 qDebug()<<"MW xml debug temp data"<<otherLosses.temperatures;
		 
		xmlBag->write();
		projectIsDirty = false; /*beacause we saved the file */
		projectName = saveProjectFile;
		
		updateTitle(projectName);
		}		
	 
// 	qDebug()<<"Mainwindo salvo progetto"<<saveProjectFile;
	}
	//SAVE ECOVAL PARAMETERS //
#ifdef PLUSVERSION
// 	if (ecoVal)
// 	{
// // 		ecoVal->save();
// // 		ecoVal->saveBands();
// // 		ecoVal->saveP();
// // 		ecoVal->saveMinP();
// 	}
#endif

}
void MainWindow::updateTitle(const QString &title)
{
	setWindowModified(false);
	
	localita.projectName = title;
	if (!title.isEmpty())
	{
		recentFiles.removeAll(title);
		recentFiles.prepend(title);
		updateRecentFileActions();	
	}
	setWindowTitle(QCoreApplication::applicationName() + tr("[*]") + " - " + title);
	
}
void MainWindow::updateRecentFileActions()
{
	QMutableStringListIterator i(recentFiles);
	while (i.hasNext()) {
		if (!QFile::exists(i.next()))
		i.remove();
	}
	for (int j =0;j< MaxRecentFiles; ++j) {
		if (j < recentFiles.count()) {
		QString text = tr("&%1 %2").arg(j+1).arg(recentFiles[j]);
		recentFileActions[j]->setText(text);
		recentFileActions[j]->setData(recentFiles[j]);
		recentFileActions[j]->setVisible(true);
		}
		else
		{ 
		recentFileActions[j]->setVisible(false);
		}
	}
	separatorAction->setVisible(!recentFiles.isEmpty());
}
void MainWindow::openRecentFile()
{
    
        QAction *action = qobject_cast<QAction *>(sender());
        if (action)
            load(action->data().toString());
     
}
void MainWindow::load()
{
	load("");
}
void MainWindow::load(const QString& f )
/* Apre un nuovo progetto */
{
	if (projectIsDirty )
	{
		if (ask()==QMessageBox::Yes){
			qDebug()<<"MW projectisDirty"<<projectIsDirty;
			save();
		}
	}
 		QString fileName;
		if (f.isEmpty())
			fileName = QFileDialog::getOpenFileName(this, tr("File progetto"), recentDirProject, tr("Solar Calc files (*.sc)"));
		else
			fileName = f;
	    	
	QPolygonF temp;
	int condition;
// 	double x,y;
	condition = 0;
    	if ( !fileName.isEmpty() )
    	{ 
		QFile file(fileName);
                QFileInfo fileInfo(fileName);
                recentDirProject = fileInfo.absoluteDir().absolutePath();
		if (xmlBag){
			
			delete xmlBag;
			xmlBag = new XmlEngine();
			xmlBag->newTree();
			QFile f(fileName);
			xmlBag->setFile(&file);
			xmlBag->read();
			localita = xmlBag->getLoc();
			thisProjectPanel.indexDB = xmlBag->getPanelId();
			thisProjectInverter.indexDB = xmlBag->getInverterId();
// 			otherLosses.tempPath  = xmlBag->getOption().tempPath;
 			otherLosses.ombrePath = xmlBag->getOption().ombrePath;
			otherLosses.nearOmbrePath = xmlBag->getOption().nearOmbrePath;
// 			otherLosses.otherLoss = xmlBag->getOption().otherLoss;
			otherLosses = xmlBag->getOption();
		#ifdef PLUSVERSION
			if (ecoVal){
// 			qDebug()<<"MW ecoVal"<<ecoVal;
				ecoVal->setEcoParameters(xmlBag->getEcoParameters());
				ecoVal->setProjectFolder(fileName);
			}
			if (inverterCheck)
				inverterCheck->setSystem(xmlBag->getSystem());
		#endif
// 			if (loadInterface){
// 				loadInterface->setFileCustom(xmlBag->getEcoParameters().loadPath);
// 				loadInterface->load();
// 			}
			
//   			qDebug()<<"Mainwindo apro progetto"<<localita.name<<localita.latGradi<<localita.latMin<<localita.latSec<<localita.lonGradi<<localita.lonMin<<localita.lonSec<<localita.area<<thisProjectInverter.indexDB<<thisProjectPanel.indexDB<<otherLosses.ombrePath<<localita.tipo;
// 			qDebug()<<"MW apro progetto..temperature"<<otherLosses.temperatures;
			projectName = fileName;
			
			updateTitle(projectName);
			updateProject();
			saveProjectFile = projectName;
			
		 } 
}
}
void MainWindow::updateProject()
{
	

	
// 	mountingValue->clear();
// 	mountingValue->addItems(QStringList()<<tr("Su guida")<<tr("BIPV")<<tr("Schiera"));
	if (!localita.name.isEmpty())
	locValue->setText(localita.name);
	else
	{
		if  (localita.latGradi!=-999){
			locValue->setText(toS(localita.latGradi)+"/"+toS(localita.latMin)+"/"+toS(localita.latSec)+","+toS(localita.lonGradi)+"/"+toS(localita.lonMin)+"/"+toS(localita.lonSec));
			useLoc = true;
// 			qDebug()<<"UPDATEPROJECT "<<useLoc<<useLoadedLoc;
			}
		else
		{
		useLoc = false;
// 		qDebug()<<"UPDATEPROJECT "<<useLoc<<useLoadedLoc;
		}
		 
	}

	thisProjectPanel = datiPanels->getSelectedPanel(thisProjectPanel.indexDB);
	concRatioValue->setValue(localita.concRatio);
	albedoValue->setValue(localita.albedo);
	
// 	utcValue->setValue(localita.utc);
	annoValue->setValue(localita.anno);
	areaValue->setValue(localita.area);
	inclValue->setValue(localita.incl);
	aziValue->setValue(localita.azi);
	altitudeValue->setValue((localita.alt));
	if (localita.tipo==2){
		areaValue2->setValue(localita.additionalArea.at(0));
		inclValue2->setValue(localita.additionalIncl.at(0));
		aziValue2->setValue(localita.additionalAzi.at(0));
	}
	otherLoss->setText(QString::number(MyMath::mean(otherLosses.otherLoss)));
// 	mountingValue->setCurrentIndex(localita.mounting);
// 	mountingHeightValue->setValue(localita.mountingHeight);
	enableHeight(mountingValue->currentIndex());
// 	if (canvas)
// 		canvas->setType(localita.mounting);
	windValue->setValue(localita.wind);
	 
	createSettings();
	
//   	qDebug()<<"MainWindow updateproject panel valid"<<thisProjectPanel.isValid<<localita.area<<thisProjectPanel.H;
	
	thisProjectInverter = datiInverter->getSelectedInverter( thisProjectInverter.indexDB);
// 	qDebug()<<"MW inverter"<<thisProjectInverter.isValid<<thisProjectInverter.indexDB;
	updateSourceRadSettings();
	
	if (!otherLosses.ombrePath.isEmpty())
		{
// 		qDebug()<<"MW UpdateProject ombrePath"<<otherLosses.ombrePath;
		
		w->setShadow(readShadow(otherLosses.ombrePath));
		 
		 
		}
	if (!otherLosses.nearOmbrePath.isEmpty())
		{ 
// 		qDebug()<<"MW UpdateProject ombrePath"<<otherLosses.ombrePath;
		QPolygonF nearS(readShadow(otherLosses.nearOmbrePath));
		 
		w->setPolyShadow(nearS);
		  
		if (editor)
			editor->setShadow(nearS);
		 
		 
		}
	 
	tempDaily = otherLosses.temperatures;
	windDaily = otherLosses.wind;
	doNotLoadTemp = true;
	doNotLoadWind = true;
	updateTempWidget();
	updateWindWidget();
// 	if (!otherLosses.tempPath.isEmpty())
// 		loadTemp(false);
// 	else
// 		if (localita.source == radNasa)
// 		/* Temperature database is emebedded */
// 		 tempDaily = extractNasaTemp(localita.latGradi,localita.lonGradi);
	 
if (!localita.name.isEmpty() || !locValue->text().isEmpty())
	setDamp();
	
}
QString MainWindow::toS(int value)
{
	return QString::number(value);
}
QString MainWindow::toS(double value)
{
	return QString::number(value);
}

void MainWindow::loadShadow()
{
	w->loadShadow();
// 	otherLosses.ombrePath = w->getFileName();
}
QString MainWindow::getMonthString(int i)
{
	
	if (i<=31) return tr("Gennaio");
	if (i>31 && i<=60) return tr("Febbraio");
	if (i>60 && i<=91) return tr("Marzo");
	if (i>91 && i<=121) return tr("Aprile");
	if (i>121 && i<=152) return tr("Maggio"); 
	if (i>152 && i<=182) return tr("Giugno");
	if (i>182 && i<=213) return (tr("Luglio"));
	if (i>213 && i<=244) return tr("Agosto");
	if (i>244 && i<=274) return tr("Settembre");
	if (i>274 && i<=305) return tr("Ottobre");
	if (i>305 && i<=335) return tr("Novembre");
	if (i>335  && i<=366) return tr("Dicembre");
return QString();//Default
}
bool  MainWindow::findNasaData(double lat, double lon,int latG, int latM, int latS, int lonG, int lonM,int lonS, int mode)

{ 
	QString searchValue;
	double A,B,C,D;
	QVector<double> a,b,c;
        QString keyl,key,keyDef;
        bool useInterp,errorRad;
//         QHash<QString,double> *tempHash;
        useInterp = false;
 	errorRad = false;

	QPolygonF temp;
        
        keyl = QString::number(latG) + "," + QString::number(latM) + "," + QString::number(latS) +","+QString::number(lonG)+","+QString::number(lonM)+","+QString::number(lonS);
	
        //If there is no value, even for one month only, interpolate: TODO//

	if (mode==0)
	nasaData.resize(0);
	if (mode==1)
	tempDaily.resize(0);
	if (mode==2)
	windDaily.resize(0);
      

        {
                if (!nasaRad.contains(keyl+",0"))
		{
//  qDebug()<<"MW FindNasa bool"<<keyl;
                        useInterp = true;
			//Find four rectangles
			A = (lat - latG ) * (lon-lonG);
			B = (lat - latG ) * (lonG+1-lon);
			C = (latG+1-lat)*(lon-lonG);
			D = (latG+1-lat)*(lonG+1-lon);
			for(int i=0;i<12;i++){
			a.resize(0);
			b.resize(0);
			c.resize(0);
					for(int k=0;k<2;k++){
						for(int l=0;l<2;l++){
					searchValue = QString::number(latG+k)+",0,0,"+QString::number(lonG+l)+",0,0,"+QString::number(i);
					if (nasaRad.contains(searchValue)){
						a<<nasaRad.value(searchValue);
// 						qDebug()<<"MW extract NASA ok:"<<a;
					}

					else
						{
// 						qDebug()<<"NASA RAD EXTRATION FAILED"<<searchValue;
						errorRad=true;
					}
					if (nasaTemp.contains(searchValue))
 						b<<nasaTemp.value(searchValue);
					else
						b<<0;
					
					if (nasaWind.contains(searchValue))
 						c<<nasaWind.value(searchValue);
					else
 					c<<0;
					 
					}
					}
				if ((mode==0) && !errorRad){
					nasaData<<(i,a.at(0)*A + a.at(1)*B + a.at(2)*C +a.at(3)*D);
// 					qDebug()<<"NASA RAD EXTRATION ADDED 0"<<searchValue;
				}
				else{
// 					qDebug()<<"NASA RAD EXTRATION NOT ADDED 0"<<searchValue<<errorRad;
					}
				if (mode==1)
					tempDaily<<b.at(0)*A + b.at(1)*B + b.at(2)*C +b.at(3)*D;
				if (mode==2)
				windDaily<<c.at(0)*A + c.at(1)*B + c.at(2)*C +c.at(3)*D;
 
			}	
		}
		else
		{
                
                for(int i=0;i<12;i++)
                        {
                                key = keyl + "," + QString::number(i);
                            
                                nasaData<<(i,nasaRad.value(key));
				tempDaily<<nasaTemp.value(key);
				windDaily<<nasaWind.value(key);
                        }
		}

	}
 
	
	return useInterp;
}
// nasaObject   MainWindow::findNasaData2(double lat, double lon,int latG, int latM, int latS, int lonG, int lonM,int lonS, int mode)
// 
// {
// 	double A,B,C,D,a,b,c,d;
//         QString keyl,key,keyDef;
//         bool useInterp;
//         QHash<QString,double> *tempHash;
//         useInterp = false;
// 	/* mode=0 FIND RAD;
// 	   mode=1 FIND TEMP;
// 	   mode=2 FIND WIND*/
// // 	QStringList campiR,campiT,campiW;
// // 
// // 	campiR<<"r1"<<"r2"<<"r3"<<"r4"<<"r5"<<"r6"<<"r7"<<"r8"<<"r9"<<"r10"<<"r11"<<"r12";
// // 	campiT<<"t1"<<"t2"<<"t3"<<"t4"<<"t5"<<"t6"<<"t7"<<"t8"<<"t9"<<"t10"<<"t11"<<"t12";
// // 	campiW<<"v1"<<"v2"<<"v3"<<"v4"<<"v5"<<"v6"<<"v7"<<"v8"<<"v9"<<"v10"<<"v11"<<"v12";
// // 	
// // 	QPolygonF temp;
// // 	QString key,keyl;
// // 	keyl = QString::number(lat) + "," + QString::number(lon);
// // 	QSqlQuery query;
// // 	if (mode==0)
// // 	query.prepare("SELECT " + campiR.join(",") + " FROM nasaData WHERE lat=:latitude AND lon=:longitude");
// // 	if (mode==1)
// // 	query.prepare("SELECT " + campiT.join(",") + " FROM nasaData WHERE lat=:latitude AND lon=:longitude");
// // 	if (mode==2)
// // 	query.prepare("SELECT " + campiW.join(",") + " FROM nasaData WHERE lat=:latitude AND lon=:longitude");
// // 	query.exec();
// // 
// // 	qDebug()<<query.lastError();
// // 
// // 	int i=0;
// // 	
// // 		while (query.next())
// // 			{
// // 			qDebug()<<query.value(i);
// // 			temp<<QPointF(0,query.value(i++).toDouble());
// // 			}
// // 		
// // 	return temp;
// 
// 	QPolygonF temp;
//         
//         keyl = QString::number(latG) + "," + QString::number(latM) + "," + QString::number(latS) +","+QString::number(lonG)+","+QString::number(lonM)+","+QString::number(lonS);
// 	
//         //If there is no value, even for one month only, interpolate: TODO//
// 
// //	if (mode==0)
//         switch (mode) {
//             case 0:
//                 tempHash = &nasaRad;
//             break;
//             case 1:
//                 tempHash = &nasaTemp;
//             break;
//             case 2:
//                 tempHash  = &nasaWind;
//             break;
//         }
// 
//         {
//                 if (!tempHash->contains(keyl+",0"))
// 		{
//                         useInterp = true;
// 			//Find four rectangles
// 			A = (lat - latG ) * (lon-lonG);
// 			B = (lat - latG ) * (lonG+1-lon);
// 			C = (latG+1-lat)*(lon-lonG);
// 			D = (latG+1-lat)*(lonG+1-lon);
// 			for(int i=0;i<12;i++){
// 				a = tempHash->value(QString::number(latG)+",0,0,"+QString::number(lonG)+",0,0,"+QString::number(i));
// 				b = tempHash->value(QString::number(latG)+",0,0,"+QString::number(lonG+1)+",0,0,"+QString::number(i));
// 				c = tempHash->value(QString::number(latG+1)+",0,0,"+QString::number(lonG)+",0,0,"+QString::number(i));
// 				d = tempHash->value(QString::number(latG+1)+",0,0,"+QString::number(lonG+1)+",0,0,"+QString::number(i));
// 				temp<<QPointF(i,a*A + b*B + c*C +d*D);
// 				qDebug()<<"MW Findnasa Interp"<<QString::number(latG)+",0,0,"+QString::number(lonG)+",0,0,"+QString::number(i)<<QString::number(latG)+",0,0,"+QString::number(lonG+1)+",0,0,"+QString::number(i)<<QString::number(latG+1)+",0,0,"+QString::number(lonG)+",0,0,"+QString::number(i)<<QString::number(latG+1)+",0,0,"+QString::number(lonG+1)+",0,0,"+QString::number(i)<<A<<B<<C<<D<<a<<b<<c<<d<<a*A + b*B + c*C +d*D;
// 			}	
// 		}
// 		else
// 		{
//                 
//                 for(int i=0;i<12;i++)
//                         {
//                                 key = keyl + "," + QString::number(i);
//                                 qDebug()<<"FINDANASA"<<key<<tempHash->value(key)<<useInterp;
//                                 temp<<QPointF(i,tempHash->value(key));
//                         }
// 		}
// 
// 	}
// //
// //	if (mode==1){
// //		for(int i=0;i<12;i++)
// //			{
// //				key = keyl + "," + QString::number(i);
// //				temp<<QPointF(i,nasaTemp[key]);
// //			}
// //	}
// //	if (mode==2){
// //		for(int i=0;i<12;i++)
// //			{
// //				key = keyl + "," + QString::number(i);
// //				temp<<QPointF(i,nasaWind[key]);
// //
// //			}
// //	qDebug()<<"Find Nasa Data wind..."<<temp;
// //	}
// //	
// 	nasaObject n;
// 	n.data = temp;
// 	n.status = useInterp;
// 	return n;
// 
// // 	QStringList splitted ;
// // 	int sLat,sLon;
// // 	QString s;
// // 	QFileInfo nasaFile(radNASAFile);
// // 	if (!nasaFile.exists())
// // 		radNASAFile = QFileDialog::getOpenFileName(this, tr("File dati NASA"), recentDir, "Text files (*.txt  )");
// // 	
// // // qDebug()<<"MW: nasa file"<<radNASAFile;
// // // 	Qfile file(":/images/nasa_rad.txt");
// // 	if (!radNASAFile.isEmpty()) {
// // 	
// // 	QFile file(radNASAFile);
// // 	if (file.open(QIODevice::ReadOnly)){
// // 		QTextStream in(&file);
// // 			while (!in.atEnd()) {
// // 				s = in.readLine();
// // 				s = s.simplified();
// // 				splitted = s.split(" ");
// // 				
// // 				
// // 				sLat = splitted.at(0).toInt();
// // 				sLon = splitted.at(1).toInt();
// // 				
// // 				if ((sLat == lat) && (sLon == lon)) {
// // 				      if (splitted.size()>2) {
// // 					splitted.removeFirst();
// // 					splitted.removeFirst();
// // //  					qDebug()<<"MW findNasaData splitted"<<splitted;
// // 					return convertListToPol(splitted);
// // 					
// // 					}
// // 					else
// // 					return QPolygonF();
// // 				 
// // 				
// // 				break;
// // 				}
// // 			}
// // 			return QPolygonF();
// // 				
// // 				
// // 			}
// // 	} else
// // 	return QPolygonF();
// }

QPolygonF MainWindow::convertListToPol(const QStringList &s)
{
	QPolygonF temp;
	for(int i=0;i<s.size();i++) {
		temp<<QPointF(i,s.at(i).toDouble());

	}
//   		qDebug()<<"MW convertList "<<temp<<temp.size();
		return temp;
}
bool MainWindow::prepareNasaTemp(QProgressBar &p,int v)
{
	QString s, sLat,sLon,keyl,key;
 	QStringList splitted ;
	int count=0; 
	bool ok=false;
	
	QFileInfo nasaFile(tempNASAFile);
	if (!nasaFile.exists()){	
			 
			return false;
	}
	else
	{
		p.setValue(v);
		QFile file(tempNASAFile);
		if (file.open(QIODevice::ReadOnly)){
			QTextStream in(&file);
			while (!in.atEnd()) {
				s = in.readLine();
				s = s.simplified();
				splitted = s.split(" ");
				p.setValue(v+count++);
				if (splitted.size()>=14){
					sLat = splitted.at(0);
					sLon = splitted.at(1);
					splitted.removeLast();
					
					splitted.removeFirst();
					splitted.removeFirst();
// 					insertNasaDatabase(sLat.toInt(),sLon.toInt(),splitted,1);//insert temp data into datiEnea.db
					 
                                        keyl = sLat + ",0,0," + sLon+",0,0";//NASA DATA do not contains decimal values!
 					for(int i=0;i<12;i++) {
 						key = keyl + "," + QString::number(i); 
 						nasaTemp[key] = splitted.at(i).toDouble();
//  						qDebug()<<key<<nasaTemp[key];
                                }
				 
				ok = true;
				}
				else{
					 
					ok = false;
					 
			}
		}
	if (ok)
		return true;
	else	return false;
	}
	else
		return false;
	}
}
bool MainWindow::prepareNasaWind(QProgressBar &p,int v)
{
	QString s, sLat,sLon,keyl,key ;
 	QStringList splitted ;
	int count=0; 
	bool ok=false;
	
	
	QFileInfo nasaFile(windNASAFile);
	if (!nasaFile.exists()){	
			 
			return false;
	}
	else
	{
  		p.setValue(v);
		QFile file(windNASAFile);
		if (file.open(QIODevice::ReadOnly)){
			QTextStream in(&file);
			while (!in.atEnd()) {
				s = in.readLine();
				s = s.simplified();
				splitted = s.split(" ");
				p.setValue(v+count++);
				if (splitted.size()>=14){
					sLat = splitted.at(0);
					sLon = splitted.at(1);
					splitted.removeLast();
					splitted.removeFirst();
					splitted.removeFirst();
// 					insertNasaDatabase(sLat.toInt(),sLon.toInt(),splitted,2);//insert temp data into datiEnea.db

                                        keyl = sLat + ",0,0," + sLon+",0,0";//NASA DATA have no decimal data!

					for(int i=0;i<12;i++) {
						key = keyl + "," + QString::number(i); 
						nasaWind[key] = splitted.at(i).toDouble();
// 						qDebug()<<key<<nasaTemp[key];
						}
				 
				ok = true;
				}
				else{
					 
					ok = false;
					 
			}
		}
	if (ok)
		return true;
	else	return false;
	}
	else
		return false;
	}
}
bool MainWindow::prepareNasaRad(QProgressBar &p, int v)
{
	

	QString s, sLat,sLon,keyl,key ;
 	QStringList splitted ;
	int count =0; 
	bool ok=false;
	
        QFileInfo nasaFile(radNASAFile);
	if (!nasaFile.exists()){	
//                          qDebug()<<"MW PREPARENASA rad not exist"<<radNASAFile;
			return false;
	}
	else
	{
 		p.setValue(v);
		QFile file(radNASAFile);
		if (file.open(QIODevice::ReadOnly)){
			QTextStream in(&file);
			while (!in.atEnd()) {
 				
				
				s = in.readLine();
				s = s.simplified();
				splitted = s.split(" ");
				p.setValue(v+count++);
				if (splitted.size()>=14){
					sLat = splitted.at(0);
					sLon = splitted.at(1);
					splitted.removeLast();
					
					splitted.removeFirst();
					splitted.removeFirst();
// 					insertNasaDatabase(sLat.toInt(),sLon.toInt(),splitted,0);//insert rad data into datiEnea.db
					keyl =  sLat  + "," +  sLon;
                                        keyl = sLat + ",0,0," + sLon+",0,0";//NASA DATA have no decimal data!
					for(int i=0;i<12;i++) {
						key = keyl + "," + QString::number(i); 
						nasaRad[key] = splitted.at(i).toDouble();
                                              //  qDebug()<<"MW PREPARE NASA RAD"<<key<<nasaTemp[key];
						}
				 
				ok = true;
				}
				else{
					  
					ok = false;
					 
			}
		}
	if (ok)
		return true;
	else	return false;
	}
	else
		return false;
	}
}
void MainWindow::insertNasaDatabase(int slat,int slon,const QStringList &data,int mode)
{
// qDebug()<<"ApplicationDir path"<<databaseEntry;
	QStringList campi,campiU;
	QString query,queryTest,queryInsert,queryUpdate;
	
	QSqlDatabase d = QSqlDatabase::database();
	if (mode>2 || mode<0) return;
	if (mode==0){
		campi<<"r1"<<"r2"<<"r3"<<"r4"<<"r5"<<"r6"<<"r7"<<"r8"<<"r9"<<"r10"<<"r11"<<"r12";
		
	}
	if (mode==1)
		campi<<"t1"<<"t2"<<"t3"<<"t4"<<"t5"<<"t6"<<"t7"<<"t8"<<"t9"<<"t10"<<"t11"<<"t12";
		
	if (mode==2)
	campi<<"v1"<<"v2"<<"v3"<<"v4"<<"v5"<<"v6"<<"v7"<<"v8"<<"v9"<<"v10"<<"v11"<<"v12";

	for(int i=0;i<12;i++) {
			campiU<<campi.at(i)+"="+data.at(i); 
			if (i<11) campiU<<",";
		}
// 	qDebug()<<campiU;
	

	
	modelRadiazione->setQuery("SELECT * from nasaData WHERE lat=" + QString::number(slat) + " AND lon=" + QString::number(slon));
	
 	queryInsert = "INSERT into nasaData (lat,lon," + campi.join(",") + ") VALUES (" +  QString::number(slat)+ ","+ QString::number(slon) + "," + data.join(",")  + ")";
	queryUpdate = "UPDATE nasaData SET " + campiU.join(" ") + "  WHERE lat=" + QString::number(slat) + " AND lon=" + QString::number(slon);
// 	query = "SELECT * from radiazione";
// 	QSqlQuery qTest;
// 	qTest.prepare(queryTest);
// 	qTest.exec();
//  
//  	qDebug()<<"nasaDatabase Test"<<modelRadiazione->rowCount()<<modelRadiazione->lastError();
	QSqlQuery q;
	if (modelRadiazione->rowCount()>0) {
// 		qDebug()<<"Update"<<queryUpdate;
                q.prepare(queryUpdate);
		q.exec();
//   		qDebug()<<"nasaDatabase"<<q.lastError()<<queryUpdate<<d.isOpen();
	}
	else {
// 		qDebug()<<"Insert"<<queryInsert;
		q.prepare(queryInsert);
		q.exec();
//  		qDebug()<<"nasaDatabase"<<q.lastError()<<queryInsert<<d.isOpen();
	}
// 	modelRadiazione->setQuery(query);
  	
}
// QPolygonF MainWindow::extractNasaTemp(int lat,int lon)
// {

// 	QPolygonF temp;
// 	QString key,keyl;
// 	keyl = QString::number(lat) + "," + QString::number(lon);
// 	for(int i=0;i<12;i++){
// 		key = keyl + "," + QString::number(i);
// 		temp<<QPoint(0,nasaTemp.value(key));
// 		qDebug()<<key<<temp;
// 		}
// 	return temp;
	
	
// 	QStringList splitted ;
// 	int sLat,sLon;
// 	QString s;
// 	QFileInfo nasaFile(tempNASAFile);
// 	if (!nasaFile.exists())
// 		tempNASAFile = QFileDialog::getOpenFileName(this, tr("File temperature NASA"), recentDir, "Text files (*.txt  )");
// 		if (!tempNASAFile.isEmpty()) {
// 		QFile file(tempNASAFile);
// 		if (file.open(QIODevice::ReadOnly)){
// 			QTextStream in(&file);
// 			while (!in.atEnd()) {
// 				s = in.readLine();
// 				s = s.simplified();
// 				splitted = s.split(" ");
// 				
// 				
// 				sLat = splitted.at(0).toInt();
// 				sLon = splitted.at(1).toInt();
// 				
// 				if ((sLat == lat) && (sLon == lon)) {
// 				      if (splitted.size()>2) {
// 					splitted.removeFirst();
// 					splitted.removeFirst();
// 					tempDataIsEdited = false;
// // 					qDebug()<<"MW findNasaData splitted"<<splitted;
// 					return convertListToPol(splitted);
// 				      }
// 				else
// 					return QPolygonF();
// 					break;
// 				}
// 			}
// 			return QPolygonF();
// 		}
// 		}
// }

void MainWindow::wizard()
{
	Suggest s;
	
	s.setPanel(thisProjectPanel);
	s.setInverter(thisProjectInverter);
// 	qDebug()<<"MW wizard"<<otherLosses.otherLoss;
	s.setLoss(MyMath::max(otherLosses.otherLoss));
	if ((reale->getUnit()-1)==0)
		s.setRad( localita.radRealeAnnuaTotale/3.6);//in kWh
	if ((reale->getUnit()-1)==1)
		s.setRad( localita.radRealeAnnuaTotale);//in kWh
// 	qDebug()<<"No plo present"<<reale->mainPlotPresent();
	if (!reale || !reale->mainPlotPresent())
	{
		s.setRad(-1);
	}

	if (s.exec()) {
			areaValue->setValue(s.getArea());
			updatePower();
		      }
	;
}
void MainWindow::print()
{ 
	QPrinter printer(QPrinter::HighResolution);
	printReport(&printer,1);
	
}
void MainWindow::printReport(QPrinter* p,int mode)
{
	
	int current = comboCurrentField->currentIndex();
	t.setDir(recentDirReport);
	if (w) {
	 
// 	 QImage sd = w->getImage();
	 
	 t.addSolarDiagram(w);
 	 t.setVersion(version);
	#ifdef PLUSVERSION
	 if (ecoVal)
	 t.setEcoParameters(ecoVal->getEcoParameters());
	 if (cash){
	 t.addVanDiagram(cash->vanDiagram());
	 t.addRawDiagram(cash->rawDiagram());
	 }
	#endif 
	 
	 
	}
	if (reale)
	{
		if (current==0){
		redrawReale(0);
		t.addSolarRadiation(reale);
		qDebug()<<"MW redrawReale for print";
		redrawReale(1);
		t.addSolarRadiation2(reale);
  		
		}
		if (current==1)
		{
		redrawReale(1);
		t.addSolarRadiation(reale);
		qDebug()<<"MW redrawReale for print";
		redrawReale(0);
		t.addSolarRadiation2(reale);
  		
		}
		
		
	}
	if (energyOut)
	{
	t.addEEnergy(energyOut);
	}
	if (validForExport){
// 		qDebug()<<"Export";
		t.addLocation(localita);
		t.addOption(otherLosses);
		 
		t.addPanel(thisProjectPanel);
		t.addInverter(thisProjectInverter);
		t.addUnitEnergy(unitE.at(energyOut->getUnit()-1));
		t.addUnitRad(unit.at(reale->getUnit()-1));
		 
		t.addRad(HinclOmbre);
		if (energyPlotPresent){
			t.addEnergy(Energy);
			t.addTotEnergy(totEnergy);
		}
		else{
		   	t.addEnergy(NULL);
			t.addTotEnergy(0);
		}
		if (cash)
			t.setTable(cash->getTable());
		#ifdef PLUSVERSION
		if (inverterCheck)	
			t.addSystem(inverterCheck->getSystem());
		#endif
		
		t.print(p,mode);
// 		if (current==0)
// 			redrawReale(0,true);
// 		if (current==1)
// 			redrawReale(1,true);
		recentDirReport = t.getDir();
	}
	

}
void MainWindow::printPreview(QPrinter* p){
	printReport(p,0);
}
void MainWindow::printPreview(){
	        QPrinter print(QPrinter::HighResolution);
              //   print.setPageSize(QPrinter::A4);
                print.setPaperSize(QPrinter::A4);
              
		QPrintPreviewDialog preview(&print,this);
		connect(&preview, SIGNAL(paintRequested(QPrinter *)), SLOT(printPreview(QPrinter*)));
		preview.exec();
}
void MainWindow::updateTiltSurface(double d)
{
	if (localita.tipo==2)
		canvas->setTilt(QVector<double>()<<inclValue->value()<<inclValue2->value());
	else
		canvas->setTilt(QVector<double>()<<d);
	
	canvas->update();	
}
void MainWindow::updateSurface(double d)
{
	if (localita.tipo==2)
		canvas->setAzimuth(QVector<double>()<<aziValue->value()<<aziValue2->value());
	else
		canvas->setAzimuth(QVector<double>()<<aziValue->value());
	canvas->update();	
}
void MainWindow::tempChangedPower()
{
    tempUpdatePower->setEnabled(true);

}
void MainWindow::windChangedPower()
{
    windUpdatePower->setEnabled(true);

}
void MainWindow::adjustVector(QVector<double> &p)
{
	/* Resize the vector to 12 values*/
	p.resize(12);
}
void MainWindow::adjustVector(QPolygonF &p)
{
	/* Resize the vector to 12 values*/
	p.resize(12);
}
void MainWindow::enableHeight(int h)
{
	if (mountingHeightValue){
		if (localita.tipo == biax)
		mountingHeightValue->setEnabled(true);
		else
		mountingHeightValue->setEnabled(false);
	if (h==rack || h==direct)
		limitDistanceValue->setVisible(false);
	else
		limitDistanceValue->setVisible(true);
		
	updatePower();
	}
}
void MainWindow::about()
{

	#ifdef PLUSVERSION
	QMessageBox::about(this,tr("Info su Solar Calc "),tr("<h2>Solar Calc - ") + version + ", " +tr(" 2009</h2>"
				"<pre style=\"font-family: Verdana, Arial, sans serif;\"> Autore      :Giuseppe De Marco </pre>"
				"<pre style=\"font-family: Verdana, Arial, sans serif;\"> Collaboratori: Giovanni Iacovoni </pre>"
				"<p>&copy; Tutti i diritti riservati a studioiacovoni.org</p>"
				"<p> Solar Calc &egrave; una applicazione per progettisti di impianti solari che usa i pi&ugrave; recenti modelli di radiazione solare. </p><p>Version ID :") + versionId + "</p>");
	#else
  	QMessageBox::about(this,tr("Info su Solar Calc "),tr("<h2>Solar Calc - ") + version + ", " +tr(" 2009</h2>"
				"<pre style=\"font-family: Verdana, Arial, sans serif;\"> Autore      :Giuseppe De Marco </pre>"
				"<pre style=\"font-family: Verdana, Arial, sans serif;\"> Collaboratori: Giovanni Iacovoni </pre>"
				"<p>&copy; Tutti i diritti riservati a studioiacovoni.org</p>"
				"<p> Solar Calc &egrave; una applicazione per progettisti di impianti solari che usa i pi&ugrave; recenti modelli di radiazione solare. La versione Community non contiene i moduli per l'analisi del capital budgeting e la verifica di compatibilit&agrave; del sistema.</p><p>Version ID :")+ versionId + "</p>");
	#endif
}
void MainWindow::newShadowEditor()
{
	
// 	editor->resetTable();
	if (editor) {
		if (editor->isHidden())
			editor->show();
		else
			editor->activateWindow();
		
			 
				
	
	}

}
void MainWindow::updateShadowFromEditor()
{
	if (w && editor){
// 			qDebug()<<editor->getShadow();
 			w->setPolyShadow(editor->getShadow());
// 			#ifdef DEBUG
			qDebug()<<"MW shadow from Myplot"<<editor->getShadow();
// 			#endif
  			w->drawShadow(3,QPolygonF());/*Cancel the preview shadow and */
  			w->drawShadow(1,QPolygonF());/*draw the combined one*/
		}
}
void MainWindow::drawShadowFromEditor()
{
		if (w && editor){
// 			qDebug()<<editor->getShadow();
// 			w->setPolyShadow(editor->getShadow());
			w->drawShadow(2,editor->getShadow());
		}

}
void MainWindow::tableResetted()
{
// 	qDebug()<<"MW editor shadow table resetted";
	if (w)
// 		w->undoCombine();
		w->delPoly();
		
}
void MainWindow::noRad(int i)
{
	if (i==all){
		w->drawMyContents(0);
		o->drawContents(0);
	}
		reale->drawContents(0,1);
		reale->drawDailyContents(0);
// 		reale->drawDailyValue(0);
		energyOut->drawContents(0);
		hourlyPlot->draw(0);
		hourlyEOPlot->draw(0);
		validForExport = false;
		updateRadLabels(reale->getUnit());
	        statusBar()->showMessage(tr("Coordinate errate, nome incompleto o dato mancante"),4000);
}

void MainWindow::updateFromGoogle()
{
//         double lat;
//         double lon;
	
	 
        if (support)
        {
		if (!support->coordinates().isNull())
		{
				double lat = support->coordinates().x();
				double lon = support->coordinates().y();
// 		               qDebug()<<"MW updateFromGoogle"<<lat<<lon;
				google.latGradi = MyMath::degree(lat);
				google.latMin   = MyMath::minute(lat);
				google.latSec   = MyMath::seconds(lat);
		
				google.lonGradi = MyMath::degree(lon);
				google.lonMin   = MyMath::minute(lon);
				google.lonSec   = MyMath::seconds(lon);
				googleError = false;
				google.lat = lat;
				google.lon = lon;
				googleNameAvailable = true;

				/*if we do not have a name from google do not use google data */
				if (!support->googleName().isEmpty()){
				google.name     = support->googleName().replace("\"","");
				
				}
				else
				{
 				
//  				googleError = true;
// 				localita.name = "";
				google.name     = support->cityLocal();
				
				}
	
				
   			#ifdef DEBUG
			qDebug()<<"MW ho chiamato updateGoogle...nome="<<google.latGradi<<google.lonGradi<<google.name<<localita.name<<support->googleName().isEmpty()<<support->coordinates()<<googleNameAvailable;
  			#endif				
				
		}
		else
		{
		googleError= true;
		googleNameAvailable = false;
		}
        }
        /* If there is no name in the italian database use google */

        if (noNameAvailable && !googleError)
        {
                localita.latGradi = google.latGradi ;
                localita.latMin   = google.latMin  ;
                localita.latSec   = google.latSec ;

                localita.lonGradi = google.lonGradi  ;
                localita.lonMin   = google.lonMin  ;
                localita.lonSec   = google.lonSec  ;
                localita.name     = google.name  ;
                localita.lat      = google.lat;
           	localita.lon      = google.lon ;
		
//    	qDebug()<<"MW ho chiamato updateGoogle e aggiornato...nome="<<localita.name<<googleError<<google.name<<noNameAvailable;
	emit gNameAvailable(localita.name);
        }
	else
		 convertLat(localita);


if (!googleNameAvailable && !bothCoord) {
	if (support)
		support->showWarn(true,tr("<font color=\"orange\">Nessun nome disponibile in Google Map. Ricontrolla le coordinate</font>"));
	}
	else
		support->showWarn(false);
if (googleError || !googleNameAvailable){

// 			qDebug()<<"UPDATEGOOEL "<<useLoc<<useLoadedLoc<<bothCoord;
 
				if (support){
						support->showWarn(true,tr("<font color=\"red\">Dati di mappatura non disponibili. Controlla la connessione</font>"));
						useLoadedLoc = true;
// 						qDebug()<<"UPDATEGOOEL 2"<<useLoc<<useLoadedLoc<<bothCoord;
				}
 
		}
	else {
	if (support){
			support->showWarn(false);
			useLoadedLoc = false;
// 			qDebug()<<"UPDATEGOOEL 3"<<useLoc<<useLoadedLoc<<bothCoord;
			}
	}

	formatCoordinates();
        comuneLat->setText(QString::number(localita.latGradi) +  "<sup>o</sup>"+ QString::number(localita.latMin) + "'" + QString::number(localita.latSec) + "''" + " ("+QString::number(localita.lat)+")" +  "<sup>o</sup>");
        comuneLon->setText(QString::number(localita.lonGradi) + "<sup>o</sup>"+ QString::number(localita.lonMin) + "'" + QString::number(localita.lonSec)+"''"   + " ("+QString::number(localita.lon)+")"+  "<sup>o</sup>");

        comuneLatS->setText(QString::number(localita.lat) +  "<sup>o</sup>");
        comuneLonS->setText(QString::number(localita.lon)+ "<sup>o</sup>");
	
//             qDebug()<<"MW ho chiamato updateGoogle in fondo..lat="<<localita.lat<<localita.lonMin;
        /* put here there result from google */
//      comuneValue->setText("");

	
}
void MainWindow::setNameDiagramPlot(const QString& a)
{
	if (!a.isEmpty()){
		if (w) {
			if ((!noNameAvailable) || googleNameAvailable && !googleError && !(onlyLat||bothCoord) )
				w->setLocName(a);
			else
				w->setLocName(localita.coordinates);
			
// 			w->replot();
		}
	}
}
void MainWindow::reloadCoordinates()
{
        updateFromGoogle();
// 	qDebug()<<"MW reloadCoordintaes";
//         googleNameAvailable = true;
//      getCity();
	/* If no name in the italian database, use google and restart */
	/* It there are bothCord there is no need to redoo all graphs */
	if ((noNameAvailable) && !bothCoord && !onlyLat)
        set();
}
void MainWindow::setVersion(const QString &v,const QString &vi,const QUrl& a)
{
        version = v;
	versionId = vi;
	urlOwner = a;
	updateTitle(projectName);
	qDebug()<<"MW VERSION "<<version<<versionId;
}
QString MainWindow::normalize(const QString &s)
{
	
	/* Convert a string into the form Yxxxx; for example agropoli --> Agropoli */
	/* or AGROPOLI -->Agropoli */
	QString result,rest,firstChar;
	
	if (s.size()>1)
	{

		firstChar = s.at(0);
		firstChar = firstChar.toUpper();
		
	
		rest = s.mid(1,s.size()-1);
		rest.toLower();

		result = firstChar + rest;
		 
		return result;
	
	}
	else
	{
		 
		return s;
	}
 
}

void MainWindow::convertToDegree(double l,double lon)
{
	/* set the localita coordinates from a decimal value*/
	localita.latGradi = MyMath::degree(l);
	localita.latMin   = MyMath::minute(l);
	localita.latSec   = MyMath::seconds(l);
	
	localita.lonGradi = MyMath::degree(lon);
	localita.lonMin   = MyMath::minute(lon);
	localita.lonSec   = MyMath::seconds(lon);
	qDebug()<<"MW convertToDegreee"<<l<<lon<<localita.latGradi<<localita.latMin<<localita.latSec<<localita.lonGradi<<localita.lonMin<<localita.lonSec;
}
void MainWindow::updateComponentStatus()
{
 	if (energyOut)
		statusLabelEnergy->setText(energyOut->getStatus());
	#ifdef PLUSVERSION
  	if (inverterCheck)
  		statusLabelInverter->setText(inverterCheck->getStatusInverter());
	#else
	if (thisProjectInverter.isValid)
		statusLabelInverter->setText(tr("Inverter = ") + thisProjectInverter.fabric + " - " + thisProjectInverter.model);
	else
		statusLabelInverter->setText(tr("Inverter assente "));
	#endif
		
	
	

}
void MainWindow::updateStatusBar(const QString &s,const QString& color)
{	
	
	updateComponentStatus();	
	statusLabelWarning->setText(tr("Rad.: ") + s);
	changeColor(*statusLabelWarning,color); 
	statusLabel->setText(tr("Sorgente: ") + source.at(localita.source));
}
void MainWindow::resetStatusBar()
{
	statusLabelInverter->setText("Inverter assente");
	if (energyOut)
	statusLabelEnergy->setText(energyOut->getStatus());
	else
	statusLabelEnergy->setText("-----");
	statusLabelWarning->setText(tr("Rad.: Database"));
	changeColor(*statusLabelWarning,""); 
	statusLabel->setText(tr("Sorgente: ") + source.at(localita.source));

}

void MainWindow::resetFlags()
{
	myplotpresent    = false;
	useLoc		 = false;
	useLoadedLoc     = false;
	wrongCoordinates = true;
	noNameAvailable  = true;
	googleNameAvailable = false;
	googleError = true;
	onlyLat = false;
	bothCoord = false;
	energyPlotPresent = false;
	 ombrePresent = false;
	 noRadiation = true;
	 validForExport = false;
	 projectIsDirty = true;
	dailyValuesPresent = false;
}
void MainWindow::formatCoordinates()
/* this function create a string from localita */
{
	localita.coordinates=  QString::number(localita.latGradi) + "<sup>o</sup>" + QString::number(localita.latMin) + "'" +    
	QString::number(localita.latSec) + "''," +
	QString::number(localita.lonGradi) + "<sup>o</sup>" + 
	QString::number(localita.lonMin) + "'" + QString::number(localita.lonSec) + "''";
 	
}
 
void MainWindow::computeHourlyValues(int month,int day)
/* This function get the hourly radiation for a specific day*/
/* day is the day in the month */
{
	double v,v2,e,declination, shadow,rb,rb2,r,r2,rrd,rrd2,integral,integralR;

	
	QPointF t;
	int doy;

	hourlyRR.resize(0);
	hourlyEO.resize(0);
	v=v2=integralR=integral=e=rrd=rrd2=r=r2=rb=rb2=0;
// 	qDebug()<<"-----------------------MW recompute o->Daily"<<somethingChanged()<<dailyValuesPresent;
	if ( (w) && (reale) )
	{
 	if ( (!dailyValuesPresent)   )
// 	if (reale->dailyIsDirty())
// 	if (validForExport)
	{
				
				o->setYear(localita.anno);
				if (localita.additionalAzi.size()>0 && localita.additionalIncl.size()>0){
					o->computeDailyRad(localita.additionalIncl.at(0)*pi/180,localita.additionalAzi.at(0)*pi/180,localita.anno);
// 					RbDaily2 	= o->getRbDaily();
					
					
					omegasHDaily2	= o->getOmegasHDaily();
					HhoDaily2	= o->getHhoDaily();
				}
					o->computeDailyRad(localita.incl*pi/180,localita.azi*pi/180,localita.anno);
// 					RbDaily  = o->getRbDaily();
// 					RbBiAxDaily	= o->getRbBiAxDaily();
// 					dailyTilt	= o->getVarTilt();
					omegasHDaily	= o->getOmegasHDaily();
					HhoDaily	= o->getHhoDaily();
// 				qDebug()<<"MW recompute o->Daily---------------"<<HhoDaily.size()<<omegasHDaily.size();
				dailyValuesPresent = true;
	}			
		
			/*Type of system, 1 is biaxial*/
// 				QPolygonF p;
// 				switch (localita.tipo){
// 				 case 0:
// 					
// 					p<<QPointF(0,localita.incl*pi/180);
// 					reale->setDailyIncl(p);
// 					reale->setRbDaily(RbDaily);
// 				 break;
// 				case 1:
// 				
// 					reale->setDailyIncl(dailyTilt);
// 					reale->setRbDaily(RbBiAxDaily);
// 				break;
// 				case 2:
// 				
// 					reale->setDailyIncl(dailyTilt());
// 					reale->setRbDaily(RbBiAxDaily());
// 				break;
// 				}
// 					reale->setOmegasDaily(o->getOmegasHDaily());
// 					reale->setHhoDaily(o->getHhoDaily());
	
		for (int hour=0;hour<24;hour++) {
			shadow      = w->hourlyOmbreFactor(localita.anno,month, day, hour);
			declination = w->getDeclinationPrime( month, day, hour);
			reale->setYear(localita.anno);
			energyOut->setYear(localita.anno);
			reale->setTotalDayLen(o->getTotalDayLen());
			energyOut->setTotalDayLen(o->getTotalDayLen());
			
			doy         = MyMath::dayOfYear(localita.anno,month,day) -1;//from  0 to 364! or 0 to 365
			 
			t  = w->computeSingleValue(hour,month,day,localita.anno) ;// sun position in degree
				// There are asymptotes in trackin mode ....to check
// 				if (t.y()<0)
// 					t.setY(0);
// 	qDebug()<<"Elev "<<t.y();
 					switch (localita.tipo) {
					case 2 :
					/* DOUBLE FACADE */
						reale->setOmegasDaily(omegasHDaily);
						reale->setHhoDaily(HhoDaily);
						
						if (t.y()<0.4){
							rb = 0;
							rb2= 0;
						}
						else{
							 
							rb  = w->getSingleRb(hour,month,day,localita.anno,localita.incl,localita.azi);
  							rb2  = w->getSingleRb(hour,month,day,localita.anno,localita.additionalIncl.at(0),localita.additionalAzi.at(0));
							 
						}
 						rrd = w->getHDiffuseRatio(hour, month, day,  localita.anno, localita.incl, 1);//Collareis-Pereira
						r   = w->getHGlobalRatio(hour, month, day,  localita.anno, localita.incl, rrd,1);//Collareis-Pereira
						rrd2 = w->getHDiffuseRatio(hour, month, day,  localita.anno, localita.additionalIncl.at(0), 1);//Collareis-Pereira
						r2   = w->getHGlobalRatio(hour, month, day,  localita.anno, localita.additionalIncl.at(0), rrd,1);//Collareis-Pereira
						 
						v = reale->getHourlyH(hour,localita.anno,month,doy, shadow,localita.lat*pi/180,localita.incl*pi/180,declination*pi/180,rb,rrd,r,localita.tipo,pereira);

						reale->setOmegasDaily(omegasHDaily2);
						reale->setHhoDaily(HhoDaily2);
						 
						v2 = reale->getHourlyH(hour,localita.anno,month,doy, shadow,localita.lat*pi/180,localita.additionalIncl.at(0)*pi/180,declination*pi/180,rb2,rrd2,r2,localita.tipo,pereira);
						 
						
					break;
					case 1 :
						
						reale->setOmegasDaily(omegasHDaily);
						reale->setHhoDaily(HhoDaily);
						
						if (t.y()<0.4)
							rb = 0;
						else{
							
							rb  = w->getSingleRb(hour,month,day,localita.anno,90-t.y(),t.x());
							
						}
						
						rrd = w->getHDiffuseRatio(hour, month, day,  localita.anno, 90-t.y(), 1);//Collareis-Pereira
						 
						r   = w->getHGlobalRatio(hour, month, day,  localita.anno, 90-t.y(), rrd,1);//Collareis-Pereira
						v = reale->getHourlyH(hour,localita.anno,month,doy, shadow,localita.lat*pi/180,localita.incl*pi/180,declination*pi/180,rb,rrd,r,localita.tipo,pereira);
					break;
					
					case 0:
						/* SINGLE FACADE */
						reale->setOmegasDaily(omegasHDaily);
						reale->setHhoDaily(HhoDaily);
						 
						if (t.y()<0.4)
							rb = 0;
						else{
// 							rb  = w->getSingleRb(hour,month,day,localita.anno,localita.incl,t.x());
							rb  = w->getSingleRb(hour,month,day,localita.anno,localita.incl,localita.azi);
							 
						}
					rrd = w->getHDiffuseRatio(hour, month, day,  localita.anno,localita.incl, 1);//Collareis-Pereira
					r   = w->getHGlobalRatio(hour, month, day,  localita.anno,localita.incl,rrd, 1);//Collareis-Pereira
					 
					v = reale->getHourlyH(hour,localita.anno,month,doy, shadow,localita.lat*pi/180,localita.incl*pi/180,declination*pi/180,rb,rrd,r,localita.tipo,pereira);
					 
					break;
					}
 
// 				}
				
				
 				e = energyOut->getHourlyValue(localita.area,v/3.6,month,doy) + energyOut->getHourlyValue(localita.additionalArea.at(0),v2/3.6,month,doy); 
              				#ifdef DEBUG
				qDebug()<<"MW hourly value hour   tilt="<<v<<v2<<e<<localita.tipo<<doy<<hour<<rb<<t.x()<<t.y()<<v<<e<<shadow<<declination<<dailyValuesPresent;
             				#endif
//  qDebug()<<"MW hourly value hour ="<<hour<<day<<r<<rrd<<rb<<v;
			if (comboCurrentField->currentIndex()==1)
				hourlyRR<<QPointF(hour,v2);
			else
				hourlyRR<<QPointF(hour,v);
	
			hourlyEO<<QPointF(hour,e);
		integral+=e;
		integralR += v;
   				
		}
		#ifdef DEBUG
   		qDebug()<<"MW total day ee and rad ="<<integral<<integralR ;
		#endif
		
	
	}
	
	
}
double MainWindow::computeHourlyValue(int month,int day,int hour,int year)
/* Return a particular value of the Energy Yield in a given date an time*/ 
{
        double v,v2,e,declination, shadow,rb,r,rrd,rb2,r2,rrd2;
	QPolygonF omegasHDaily,omegasHDaily2,HhoDaily,HhoDaily2;

	QPointF t;
	int doy;
// 	hourlyRR.resize(0);
// 	hourlyEO.resize(0);
	 rb=v=v2=e=rb2=rrd2=rrd=r=r2=0;
	if ( (w) && (reale) )
	{
  	 
	if ( (!dailyValuesPresent)  || somethingChanged() )
// 	if (reale->dailyIsDirty())
// 	if (validForExport)
	{
// 				qDebug()<<"MW recompute o->Daily";
				o->setYear(localita.anno);
				if (localita.additionalAzi.size()>0 && localita.additionalIncl.size()>0){
					o->computeDailyRad(localita.additionalIncl.at(0)*pi/180,localita.additionalAzi.at(0)*pi/180,localita.anno);
// 					RbDaily2 	= o->getRbDaily();
					
					
					omegasHDaily2	= o->getOmegasHDaily();
					HhoDaily2	= o->getHhoDaily();
				}
					o->computeDailyRad(localita.incl*pi/180,localita.azi*pi/180,localita.anno);
// 					RbDaily  = o->getRbDaily();
// 					RbBiAxDaily	= o->getRbBiAxDaily();
// 					dailyTilt	= o->getVarTilt();
					omegasHDaily	= o->getOmegasHDaily();
					HhoDaily	= o->getHhoDaily();
			dailyValuesPresent = true;

	}				
		
			/*Type of system, 1 is biaxial*/
// 				QPolygonF p;
// 				switch (localita.tipo) {
// 					case 0:
// 					
// 					p<<QPointF(0,localita.incl*pi/180);
// 					reale->setDailyIncl(p);
// 					reale->setRbDaily(o->getRbDaily());
// 					break;
// 					case 1:
// 					reale->setDailyIncl(o->getVarTilt());
// 					reale->setRbDaily(o->getRbBiAxDaily());
// 					break;
// 				}
// 					reale->setOmegasDaily(o->getOmegasHDaily());
// 					reale->setHhoDaily(o->getHhoDaily());
	
		 
			shadow      = w->hourlyOmbreFactor(year,month, day, hour);
			declination = w->getDeclinationPrime( month, day, hour);
			reale->setYear(year);
			energyOut->setYear(year);
			reale->setTotalDayLen(o->getTotalDayLen());
			reale->setMeanDayLen(o->getMeanDayLen());
			energyOut->setTotalDayLen(o->getTotalDayLen());
			
			doy         = MyMath::dayOfYear(year,month,day) -1;//from  0 to 364! or 0 to 365
			 
			t  = w->computeSingleValue(hour,month,day,year) ;// sun position in degree
				// There are asympots in trackin mode ....to check
// 				if (t.y()<0)
// 					t.setY(0);
	 
					switch (localita.tipo) {
					case 2 :
					/* DOUBLE FACADE */
						reale->setOmegasDaily(omegasHDaily);
						reale->setHhoDaily(HhoDaily);
						
						if (t.y()<0.4){
							rb = 0;
							rb2= 0;
						}
						else{
							 
							rb  = w->getSingleRb(hour,month,day,localita.anno,localita.incl,localita.azi);
  							rb2  = w->getSingleRb(hour,month,day,localita.anno,localita.additionalIncl.at(0),localita.additionalAzi.at(0));
							 
						}
 						rrd = w->getHDiffuseRatio(hour, month, day,  localita.anno, localita.incl, 1);//Collareis-Pereira
						r   = w->getHGlobalRatio(hour, month, day,  localita.anno, localita.incl, rrd,1);//Collareis-Pereira
						rrd2 = w->getHDiffuseRatio(hour, month, day,  localita.anno, localita.additionalIncl.at(0), 1);//Collareis-Pereira
						r2   = w->getHGlobalRatio(hour, month, day,  localita.anno, localita.additionalIncl.at(0), rrd,1);//Collareis-Pereira
						 
						v = reale->getHourlyH(hour,localita.anno,month,doy, shadow,localita.lat*pi/180,localita.incl*pi/180,declination*pi/180,rb,rrd,r,localita.tipo,pereira);

						reale->setOmegasDaily(omegasHDaily2);
						reale->setHhoDaily(HhoDaily2);
						 
						v2 = reale->getHourlyH(hour,localita.anno,month,doy, shadow,localita.lat*pi/180,localita.additionalIncl.at(0)*pi/180,declination*pi/180,rb2,rrd2,r2,localita.tipo,pereira);
						 
						
					break;
					case 1 :
						
						reale->setOmegasDaily(omegasHDaily);
						reale->setHhoDaily(HhoDaily);
						
						if (t.y()<0.4)
							rb = 0;
						else{
							
							rb  = w->getSingleRb(hour,month,day,localita.anno,90-t.y(),t.x());
							
						}
						
						rrd = w->getHDiffuseRatio(hour, month, day,  localita.anno, 90-t.y(), 1);//Collareis-Pereira
						 
						r   = w->getHGlobalRatio(hour, month, day,  localita.anno, 90-t.y(), rrd,1);//Collareis-Pereira
						v = reale->getHourlyH(hour,localita.anno,month,doy, shadow,localita.lat*pi/180,localita.incl*pi/180,declination*pi/180,rb,rrd,r,localita.tipo,pereira);
					break;
					
					case 0:
						/* SINGLE FACADE */
						reale->setOmegasDaily(omegasHDaily);
						reale->setHhoDaily(HhoDaily);
						 
						if (t.y()<0.4)
							rb = 0;
						else{
// 							rb  = w->getSingleRb(hour,month,day,localita.anno,localita.incl,t.x());
							rb  = w->getSingleRb(hour,month,day,localita.anno,localita.incl,localita.azi);
							 
						}
					rrd = w->getHDiffuseRatio(hour, month, day,  localita.anno,localita.incl, 1);//Collareis-Pereira
					r   = w->getHGlobalRatio(hour, month, day,  localita.anno,localita.incl,rrd, 1);//Collareis-Pereira
					 
					v = reale->getHourlyH(hour,localita.anno,month,doy, shadow,localita.lat*pi/180,localita.incl*pi/180,declination*pi/180,rb,rrd,r,localita.tipo,pereira);
					 
					break;
					}
					
 
	
 				 
				e = energyOut->getHourlyValue(localita.area,v/3.6,month,doy) + energyOut->getHourlyValue(localita.additionalArea.at(0),v2/3.6,month,doy); /*in kWh */
				if (e<0) {
					qDebug()<<"MW hourly value hour  DEBUG tilt="<<localita.tipo<<doy<<hour<<rb<<t.x()<<t.y()<<v<<e<<shadow<<declination<<dailyValuesPresent;
					exit(-1);
				}
    				#ifdef DEBUG
				qDebug()<<"MW hourly value hour   tilt="<<localita.tipo<<doy<<hour<<rb<<t.x()<<t.y()<<v<<e<<shadow<<declination<<dailyValuesPresent;
    				#endif
// 				qDebug()<<"MW hourly value hour ="<<hour<<day<<r<<rrd<<rb<<v;
    			 
 				return e;
 
			 
   				
		 
		 
	}
	else
	return 0;
}
void MainWindow::changeDays( )
{
	localita.anno = annoValue->value();
	if (selectDay){
		selectDay->clear();
		selectDay->addItems(MyMath::stringSerie(1,MyMath::monthEnd(selectMonth->currentIndex()+1,localita.anno)));
		selectDay->setCurrentIndex(0);
//  		qDebug()<<"MW changeDays"<<selectDay->currentIndex();
		
	}
}
void MainWindow::dayChanged(int day)
{
	if (day>=0) {
// 		qDebug()<<"MW dayChanged noRadiation"<<noRadiation<<selectDay->currentIndex();
		QPolygonF a;
		if (!noRadiation)
		{
	// 	computeHourlyValues(selectMonth->currentIndex()+1,selectDay->currentIndex()+1);
	// 	hourlyPlot->setHourlyData(hourlyRR);
	// 	hourlyEOPlot->setHourlyData(hourlyEO);
	// 	hourlyPlot->draw(1);
	// 	hourlyEOPlot->draw(1);
		drawHourlyValues();
		}
		else
		{
			hourlyPlot->draw(0);
			hourlyEOPlot->draw(0);
		}
	}

}
int MainWindow::numPanels(double a)
{
if (thisProjectPanel.isValid){
	 if (thisProjectPanel.H>0 && thisProjectPanel.L>0){
                 return ((int)floor( (a*1000000.0)/(thisProjectPanel.H*thisProjectPanel.L))); /*H and L  in mm */
//   		qDebug()<<"MW numPanels"<<a<<(a*10000)/(thisProjectPanel.H*thisProjectPanel.L);
		}
	else
		return 0;
	}
	
else 
	return 0;
}
void MainWindow::changeNumPanels2(double a)
/* Change the num of panels based on the area a*/
{ 
	
		if (thisProjectPanel.isValid)
			numOfPanelsValue2->setText(QString::number(numPanels(a)));
		else
			numOfPanelsValue2->setText(QString(tr("<font color=\"red\"> pannello assente </font>")));
	
}
void MainWindow::changeNumPanels(double a)
/* Change the num of panels based on the area a*/
{ 
	
		if (thisProjectPanel.isValid)
			numOfPanelsValue->setText(QString::number(numPanels(a)));
		else
			numOfPanelsValue->setText(QString(tr("<font color=\"red\"> pannello assente </font>")));
	
}
void MainWindow::updateLimitDistance(double swap,double incl)
{
	double temp,elev;
	int month;
	month = w->lowestMonth(localita.lat);
        elev  = w->computeSingleValue(10,month,21,localita.anno).y()*pi/180;
	if (swap==1){
	temp = thisProjectPanel.H;
	thisProjectPanel.H = thisProjectPanel.L;
	thisProjectPanel.L = temp;
	}
	if ((thisProjectPanel.isValid) && w && (localita.tipo==0)) {
		
		limitDistance = thisProjectPanel.H*sin((pi/180)*incl) / (tan( elev ) ) + thisProjectPanel.H*cos(incl*(pi/180));
// 		qDebug()<< limitDistance<<elev<<thisProjectPanel.H<<thisProjectPanel.L<<incl;
		limitDistanceValue->setText(QString::number(limitDistance));
		}
	if (localita.tipo==1){
			limitDistance = 1000*((mountingHeightValue->value() + trackDimValue->value()/(2*cos(elev) )) / (tan(elev)) + trackDimValue->value()/2 * sin(elev));
			limitDistanceValue->setText(QString::number(limitDistance));
		qDebug()<<"MW limit distance"<< limitDistance<<elev<<thisProjectPanel.H<<thisProjectPanel.L<<incl<<elev<<trackDimValue->value()<<mountingHeightValue->value();
}
		
}
void MainWindow::updateLimitDistance(double incl)

{
	updateLimitDistance(0,incl);
}
void MainWindow::updateLimitDistance()

{
	updateLimitDistance(1,localita.incl);
}
void MainWindow::simulateNew()
{
	int r = QMessageBox::question(this,tr("Nuova simulazione energetica"),tr("Cancello i dati della precedente simulazione e ne inizio una nuova?"),QMessageBox::Ok|QMessageBox::Cancel,QMessageBox::Cancel	);
	
	if (r== QMessageBox::Ok){
		firstPassDone = false;
		simulate(energetics);
	}
	
}

void MainWindow::simulateNewEco()
{
	int r = QMessageBox::question(this,tr("Nuova simulazione economica"),tr("Cancello i risultati precedenti e inizio una nuova simulazione?"),QMessageBox::Ok|QMessageBox::Cancel,QMessageBox::Cancel	);
	
	if (r== QMessageBox::Ok){
		
		simulate(economics);
	}
	
}
void MainWindow::simulate(int mode)
/* Perform the simulatio of a certain number of years*/
{
#ifdef PLUSVERSION
	int anni,year,em,err,k,dayCount;
	double credit,inflow,outflow,e,c,cumRataNPV,amm,tempE,es[24],scale;
	QPolygonF eiToPlot,eprToPlot;
// 	QVector<double> temp,eprod,ei,eprv,opr,ec;
	
	
		
		
		
		 
		
		CS.resize(0);
		RawCash.resize(0);
		NPV.resize(0);
		Interest.resize(0);
		InterestNPV.resize(0);
		Rata.resize(0);
		RataNPV.resize(0);
		consumedEn.resize(0);
		err = 0;
// 		qDebug()<<"OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO";	
		if ((ecoVal && ecoVal->bandError()) && mode==economics)
				err +=1;
		
// 		qDebug()<<"OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO2";	
 		if ((ecoVal) && (cash)	&& mode==economics){
			ecoVal->setInstalledPower(thisProjectPanel.pnom * numPanels(localita.area)/1000);
			
			ecopara he = ecoVal->getEcoParameters();
  			cash->setEcoParameters(he);
		}
// 		qDebug()<<"OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO3";	
		
// 		qDebug()<<"MW "<<noRadiation<<thisProjectPanel.isValid;
		if ((ecoVal) && (!noRadiation) && (thisProjectPanel.isValid) && err<1) {
			
			amm    = ecoVal->getDepreciation();
			
			ecoVal->checkBands();
			
  			anni = ecoVal->dPeriodo->value();
			QProgressDialog progress(tr("Simulazione avviata...attendere"),tr("Ferma simulazione"),0,anni,this);
			progress.setWindowModality(Qt::WindowModal);
	 		progress.setMinimum(0);
		
		
			year = localita.anno;
			credit = 0;
			/* Compute one-shot prediction of energy prices */
//     			ecoVal->processEnergyPrices(anni);
// 			for (int i=0;i<anni;i++) {
// 			year +=i;
			
			/*Build tables: Compute values for the first year */
			/* Only for the first year. We assume subsequent years similar*/
			 
				
					/* Only for the first year. We assume subsequent years similar*/
				if ((firstPassDone == false) || mode==energetics)
				{
					resetEnString();
					progress.setMaximum(12*31*24);
					progress.setLabelText( tr("Nuova simulazione avviata...")) ;
					temp.resize(0);
					ei.resize(0);
					eprv.resize(0);
					opr.resize(0);
					ec.resize(0);
					eprod.resize(0);
					k=0;
					dayCount = 1;
						for(int month=0;month<12;month++) {
						progress.setValue(month*31*24);
							em = MyMath::monthEnd(month+1,2004);//month from 1 to 12. Default year = 366
// 							ss =0;
							tempE = 0;
							scale=1;
							for(int day=1;day<=em;day++) {
// 									qDebug()<<"SIMULATEe "<<dayCount<<MyMath::refDay(month);
									if (dayCount==MyMath::refDay(month))
										energString +="<tr><td>" + MyMath::months(month+1) + "</td>";
									
										for(int hour=0;hour<24;hour++){
											es[hour] = computeHourlyValue(month+1,day,hour,year);
											tempE += es[hour];/*in kWh*/
											}
									if (otherLosses.scaling){
										scale = Energy[month]/tempE;
									}
									else
										scale = 1;
	
									for(int hour=0;hour<24;hour++){
// 										c = loadInterface->getHourlyLoad(year,hour,month+1);						
// 										ec    << c;  /*consumed*/
										e = es[hour] * scale;
// 										e =computeHourlyValue(month+1,day,hour,year)*scale;
	 									eprod << e ; /*produced*/
										
										if (dayCount==MyMath::refDay(month))
											if (e>0.000000002)
											energString +="<td style=\"background-color : #56ab1e;\">" + QString("%1").arg(e,2,'f') + "</font></td>";
											else
											energString +="<td>" + QString("%1").arg(e,2,'f') + "</td>";
// 						
										
 									
										if (std::isnan(e)) {
   										qDebug()<<"MW simulate iterations first pass....................."<<k<<eprod.at(k)<<e;
										return;
										}
										if (e<0){
											qDebug()<<"EPROD NEGATIVE..."<<k<<e<<month<<day<<hour<<year<<scale;
											exit(-1);
										}
										k++;
										}
							if (dayCount==MyMath::refDay(month))
								energString +="</tr>";
							dayCount++;
							}
						
//        						qDebug()<<"MW simualte......................... test eprod"<<month<<MyMath::cumSum(eprod);
						
						}
				firstPassDone = true;
				energString+="</table><p>" + tr("Valori in kWh") + "</p>";
				updateHourlyTable();
				
//   				qDebug()<<"MW energyString"<<energString;
				}
				else	{
					progress.setMaximum(12*anni);
					progress.setLabelText( tr("Aggiornamento simulazione precedente..."));
					}
				 
				if (mode==economics)
				{

					/* Start cycle over all the years */	
					double ei_,eprod_,epr_,opr_,ec_,reduction,r,cumEprod_,raw,npv,tempE,interest,interestNPV;
					double consumed_,eprv_;
					ei_=eprod_=epr_=opr_=inflow=ec_=interest=interestNPV=cumRataNPV=0;
					r = thisProjectPanel.gar;
					
					raw = -ecoVal->getInitialCost() + ecoVal->getTaxReduction() + ecoVal->getTaxVatReduction() +ecoVal->getBonusPerkWp()*installedPower();
					npv = raw ;
					ecoVal->computeLoan();
// 					double csx[anni],csy[anni];
					/* Year of start */
					RawCash<<QPointF(0,raw);
					NPV<<QPointF(0,npv);
					Interest<<QPointF(0,interest);
					InterestNPV<<QPointF(0,interestNPV);
					Rata<<QPointF(0,0);
					RataNPV<<QPointF(0,0);

					yearlyEprod.resize(0);
					yearlyCost.resize(0);
					yearlyCostNPV.resize(0);
					consumedEn.resize(0);
					BN.resize(0);
					CS.resize(0);
					AmmNPV.resize(0);


					
					yearlyEprod<<QPointF(0,0);
					yearlyCost<<QPointF(0,0);
					yearlyCostNPV<<QPointF(0,0);
					BN<<QPointF(0,0);
					CS<<QPointF(0,0);
					consumedEn<<QPointF(0,0);
					AmmNPV<<QPointF(0,0);
					
					
					
					for (int i=1;i<=anni;i++){
						if (progress.wasCanceled())
							
							break;
						k=0;
						Ei.resize(0);
						Epr.resize(0);
						Opr.resize(0);
						
						Eprod.resize(0);
						

						reduction = i>0 ? (1-r*i/100) : 1;
						year =localita.anno + i;
						consumed_= cumEprod_=0;
						for(int month=0;month<12;month++) {
							epr_=ei_=opr_=tempE=eprv_=0;
							progress.setValue(12*i + month);
							em =   MyMath::monthEnd(month+1,year);
							tempE = 0;
							for(int day=1;day<=em;day++) {
								for(int hour=0;hour<24;hour++){
									c = loadInterface->getHourlyLoad(year,hour,day,month+1);
									eprod_ = reduction* (eprod.at(k)); //Energy produced and reduced by time
// 									ec_    = ec.at(k); //Load
									ec_    = c; //Load
									ei_   += (eprod_-ec_) >0 ? eprod_-ec_ : 0; // Injected. If 
									epr_   = (eprod_-ec_)>0 ? 0          : ec_-eprod_;// Fetched ener.
									opr_  += epr_ * ecoVal->getEnergyCost(hour,month,day,month)/100;// Monetary value of fetched ener.
 									eprv_ += epr_;
									cumEprod_ += eprod_;// Produced energy in one year in kWh
									consumed_  += c;     //consumed energy in one year
									tempE += eprod_;
		// 							/*****DEBUG***/
									if (std::isnan(eprod_)) {
										qDebug()<<"MW simulate iterations cycle........"<<k<<eprod.at(k);
										exit(-1);
									}
									if (eprod_<0){
										qDebug()<<"MW simulate iterations cycle eprod NEGATIVE........"<<k<<year<<month<<day<<hour<<eprod.size()<<reduction<<eprod_;
										exit(-1);
									}
//  									if (MyMath::leapYear(year))
//  			  							qDebug()<<"MW LOAD at h"<<year<<month<<day<<hour<<ec_<<consumed_;
									k++;
								}
							} 
							/* End of month */
								Epr<<QPointF(i,eprv_);
								Ei<< QPointF(i,ei_);
								Opr<<QPointF(i,opr_);
								Eprod<<QPointF(i,tempE);
  								#ifdef DEBUG
  								qDebug()<<"MW simulate cycle anno..."<<year<<i<<epr_<<ec_<<ei_<<opr_<<reduction<<tempE<<cumEprod_<<localita.anno<<localita.area;
  								#endif
								
						}
						/*End of the current year. 12 values ready */
						/*Compute the contribute due to the injection of energy for a particular year plus bonuses*/
						
						temp =ecoVal->getContribute(Eprod,Epr,Ei,Opr,credit,i);/*see the doc of ecoval->getCOntribute, it's a value in cents*/
		
						inflow =temp.at(0) + temp.at(4) * cumEprod_ ;
						CS<<QPointF(i,temp.at(0));
						BN<<QPointF(i,temp.at(4)*cumEprod_);
// 						csx[i] = i;
// 						csy[i] = inflow;
						outflow = ecoVal->getYearlyCost() + ecoVal->getFreqCosts(i) + ecoVal->getYearlyAssic();
						
						eiToPlot<<QPointF(i,MyMath::cumSum(Ei));
						eprToPlot<<QPointF(i,MyMath::cumSum(Epr));
						credit += temp.at(2);
		
						interest    = ecoVal->getYearlyInterest(i); //the interet amount of borrowed capital
						interestNPV = ecoVal->getYearlyInterestNPV(i );// the actual value of the borrowed capital
						cumRataNPV += ecoVal->getYearlyLoanNPV(i);
						raw += inflow-outflow -ecoVal->getYearlyLoan(i) + ecoVal->getYearlyTaxReductionOnInterest(i) + amm;
						npv +=ecoVal->getNPVFactor(inflow-outflow,i) - ecoVal->getYearlyLoanNPV(i) + ecoVal->getYearlyTaxReductionOnInterestNPV(i) + ecoVal->getDepreciationNPV(i) - ecoVal->getYearlyAssicNPV(i);
						RawCash <<QPointF(i,raw );
						yearlyCost<<QPointF(i,outflow);
						yearlyCostNPV<<QPointF(i,ecoVal->getNPVFactor(outflow,i));
						NPV     <<QPointF(i,npv);
						Rata   << QPointF(i,ecoVal->getYearlyLoan(i));
						RataNPV<<QPointF(i,ecoVal->getYearlyLoanNPV(i));
						Interest <<QPointF(i,interest);
						InterestNPV<<QPointF(i,interestNPV);
						yearlyEprod<<QPointF(i,cumEprod_);
						consumedEn<<QPointF(i,consumed_);
						AmmNPV<<QPointF(i,ecoVal->getDepreciationNPV(i));
//   						qDebug()<<"MW simulate contribute"<<CS.at(i).y()<<i<<temp.at(0)<<temp.at(4)<<cumEprod_<<inflow<<raw<<npv<<interest;
						

					}
					/* end of simulation */
		// 			ecoVal->drawEi(eiToPlot);
		// 			ecoVal->drawEp(eprToPlot);
// 					qDebug()<<"MW simulate NPV"<<npv;
// 					qDebug()<<"MW simulate RAW"<<raw;
					cash->setYearlyCostNPV(yearlyCostNPV);
					cash->setYearlyCost(yearlyCost);
					cash->setRata(Rata);
					cash->setRataNPV(RataNPV);
					cash->setProduced(yearlyEprod);
					cash->setConsumed(consumedEn);
					cash->setBonus(BN);
					cash->setCS(CS);
					cash->setInterest(Interest);
					cash->setInterestNPV(InterestNPV);
					cash->setRawCash(RawCash);
					cash->setNPV(NPV);
					cash->setAmmNPV(AmmNPV);
					cash->setAmm(amm);

					cash->drawFlowCash();
					cash->drawNPV();
				
				
					cash->toggleInterestPlot(toggleInterest->checkState());
					cash->drawInterest();
					cash->drawInterestNPV();
				
					/* Copy data to tables*/
				}
				else
					return;	
	// 			ecoVal->drawCS(csx,csy,anni);
		}
		else
		{
			switch (err){
			case 1:
				QMessageBox::warning(this,tr("Prezzi orari energia"),tr("Dati orari del costo dell'energia mancanti.Controlla dal menu Strumenti->Configura parametri economici"));
			break;
			
			}
			if (noRadiation)
				QMessageBox::warning(this,tr("Dati radiazione"),tr("Nessun dato di radiazione presente. Hai selezionatao una sito?"));
			if (!thisProjectPanel.isValid)
				QMessageBox::warning(this,tr("Pannello assente"),tr("Nessun pannello fotovoltaico selezionato. Non posso generare i dati energetici senza un pannello. Scegliene uno dal menu Strumenti."));
		}
// 			
		
		
	#endif
}


    void MainWindow::drawRefCurve()
{
// 	double gain;
	
	if (reale){
		
		if (!refCurveShown){
			tiltButton->setText(tr("Nascondi"));
			if (!noRadiation){
			reale->viewRefCurve(true);
			reale->drawRefCurve(1);
			}
			
// 			gain = (noRadiation==false) ? MyMath::cumSumMonthly(reale->getHref(),12) : 0;
// 			gain = 100*(gain - localita.radRealeOmbreAnnuaTotale)/localita.radRealeOmbreAnnuaTotale;
// 			gainValue->setText(QString::number(gain)+" %");
			refCurveShown = true;
			
		}
		else{
			tiltButton->setText(tr("Visualizza"));
			if (!noRadiation)
				{
				reale->viewRefCurve(false);
				reale->drawRefCurve(0);
				}
			refCurveShown = false;
// 			gainValue->setText("0 %");
		}
	}
		

}    
	
 
void MainWindow::paintEvent(QPaintEvent * /* event */)
{
/*	
// 		italiaData->setVisible(showItalia);
	if (localita.source==radEnea){
	if (bF)
		bF->close();

		bF = new FaderWidget(italiaData);
		 bF->start(showItalia);
	}
	
*/

}
 void MainWindow::fadeInWidget(int start)
{ 

// italiaData->setVisible(start);
// showItalia = start;

//THIS DOES NOT WORK
if (localita.source==radEnea){
	if (bF)
		bF->close();

		bF = new FaderWidget(pagesWidget->widget(start));
                bF->start();
 }
	
}
void MainWindow::createCheckInverter()
{
#ifdef PLUSVERSION
  	if (inverterCheck && !noRadiation && o){
		inverterCheck->setDatabase(databasePanelsId);
  		inverterCheck->setInverter(thisProjectInverter);
 		inverterCheck->setPanel(thisProjectPanel);
		if (localita.additionalArea.size()>0)
		inverterCheck->setNumPanels(numPanels(localita.area) + numPanels(localita.additionalArea.at(0)));
		else
		inverterCheck->setNumPanels(numPanels(localita.area));

 		inverterCheck->setThermalModel(otherLosses.thermalModel);
		inverterCheck->setRad(HinclOmbre,reale->getUnit());
		inverterCheck->setAddRad(HinclOmbre2,reale->getUnit());
 		inverterCheck->setMeanDayLen(o->getMeanDayLen());
 	 	inverterCheck->setWind(windDaily);
 		inverterCheck->setMounting(mountingValue->currentIndex(),mountingHeightValue->value());
 		QVector<double> t;
 		t<<localita.tempMin<<localita.tempMax;
 		inverterCheck->setTemp(t);
		inverterCheck->checkAll();
	updateComponentStatus();
  	}
#endif
}
void MainWindow::closeEvent(QCloseEvent *event)
{
	int a;
if (projectIsDirty)
	{
		a = ask();
	        if (a==QMessageBox::Yes ){
			QSqlDatabase::removeDatabase("panels");
			save();	
		
		}
		if (a==QMessageBox::Cancel) {
			event->ignore();
			qDebug()<<"MW CLOSE ignore";
			return;}
			
		event->accept();
		 
	}
	 
	writeSettings();
	 
 
	
}
void MainWindow::drawInterest(int i)
{
	
		if (cash){
					cash->toggleInterestPlot(i);
					cash->drawFlowCash();
					cash->drawNPV();
					cash->drawRata();
					cash->drawRataNPV();
		}
}
void MainWindow::prepareNasaGlob(QProgressBar &p,int v)
{
	QString s, sLat,sLon,keyl,key;
 	QStringList splitted ;
	int count=0; 

	
	QFileInfo nasaFile(globalNASAFile);
	if (!nasaFile.exists()){	
			 
			return ;
	}
	else
	{
		p.setValue(v);
		QFile file(globalNASAFile);
		if (file.open(QIODevice::ReadOnly)){
			QTextStream in(&file);
			while (!in.atEnd()) {
			s = in.readLine();
				s = s.simplified();
				splitted = s.split(" ");
				p.setValue(v+count++);
				if (splitted.size()>=38){
					sLat = splitted.at(0);
					sLon = splitted.at(1);
					splitted.removeFirst();
					splitted.removeFirst();
// 					insertNasaDatabase(sLat.toInt(),sLon.toInt(),splitted,1);//insert temp data into datiEnea.db
					 
                                        keyl = sLat + ",0,0," + sLon+",0,0";//NASA DATA do not contains decimal values!
 					for(int i=0;i<12;i++) {
 						key = keyl + "," + QString::number(i); 
 						nasaRad[key] = splitted.at(i).toDouble();
					}
					for(int i=12;i<24;i++) {
 						key = keyl + "," + QString::number(i); 
 						nasaTemp[key] = splitted.at(i).toDouble();
					}
					for(int i=24;i<36;i++) {
 						key = keyl + "," + QString::number(i); 
 						nasaWind[key] = splitted.at(i).toDouble();
					}
				}
						


			}
		}
	}
}
void MainWindow::updateHourlyTable()
{
	if (energySummary)
		energySummary->setHtml(energString);

}
void MainWindow::resetEnString()
{
energString = "<table style=\"font-size : 9px;\" border=1 width=\"100%\" cellspacing=\"0\" cellpadding=\"3\" bordercolor=\"#980000\" >"
		      "<tr  bgcolor=\"#C89800\"><td >" + tr("Mese") + "</td>" + MyMath::serieCellTable(0,24)+ "</tr>" ;
}
void MainWindow::enableScaling(int state)
{
	if (state==Qt::Checked){
		otherLosses.scaling = true;
		
	}
	else
	{
		otherLosses.scaling = false;
		
	}
	qDebug()<<"MW scaling"<<otherLosses.scaling;
	
	if (selectMonth->currentIndex()<12){
		hourlyPlot->setMode(otherLosses.scaling,HinclOmbre[selectMonth->currentIndex()]);
		hourlyEOPlot->setMode(otherLosses.scaling,Energy[selectMonth->currentIndex()]/MyMath::monthEnd(selectMonth->currentIndex()+1,localita.anno));
		hourlyPlot->setHourlyData(hourlyRR);
		hourlyEOPlot->setHourlyData(hourlyEO);
		hourlyPlot->draw(1);
		hourlyEOPlot->draw(1);
	}
}

void MainWindow::enableDrawingLoads()
{
	if (checkDrawLoads)
		if (hourlyEOPlot)
		hourlyEOPlot->enableDrawingLoads(checkDrawLoads->isChecked());
}

void MainWindow::checkUpdates()
{
	
	ch->setVersion(versionId);
	ch->show();
	 
	ch->doDownload(urlOwner);
	
			
	 
}
void MainWindow::redrawReale(int whichone)
/* whichone comes from a combo. Add 1 to match reale->drawContents*/
{
 	
	if (whichone<=localita.additionalIncl.size() && !noRadiation){
	
	if (checkOmbre->isChecked())
		reale->drawContents(2,whichone+1);
	else
		reale->drawContents(1,whichone+1);
	}
	drawHourlyValues();
	updateRadLabels(reale->getUnit());
}
 
void MainWindow::redrawSelfShadow(int m)
{
    w->setCurrentSide(m);

        w->toggleSelfShadow(toggleSelfShadowBox->checkState());
}
